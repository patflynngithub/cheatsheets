
Modified: 05/09/19

To Do:
------

- better understanding of rebasing and its potential problems

Git Cheatsheet
==============

Mostly based on:

    Pro Git, 2nd edition, Chacon and Straub

Quick Hits
----------

git config

git add -A .
git commit -m "Final revision before sending out Lesson 1"
git push origin master

git commit --amend

git fetch
git pull   (combo of git fetch and git merge)
git reset
git rm
git mv
git clean
git rebase

git status
git log
git remote
git remote add
git remote show
git diff     (git difftool)
git show
git shortlog

git branch branch-name
git branch -d branch-name
git checkout branch-name
git checkout -b <branch_name>
git checkout -- <file>         (to discard changes in working directory)


git merge <filename>    (git mergetool)
git stash
git tag

git help


SETUP
-----

	git config --global user.name "Firstname Lastname" (whatever yours is)
	git config --global user.email "your@email.address" (whatever yours is)
	git config --global credential.helper 'cache --timeout=3600'
	git config --global core.editor "gedit -w -s"  (or whatever text editor you use)

    git init
	git clone https://github.com/your-github-account-name/pycnumanal-lessons

-------------------------------------------------------

- Git is a DVCS

    Distributed Version Control System


- The major difference between Git and any other VCS (Subversion and friends
  included) is the way Git thinks about its data. Conceptually, most other systems
  store information as a list of file-based changes. These systems (CVS, Subver-
  sion, Perforce, Bazaar, and so on) think of the information they keep as a set of
  files and the changes made to each file over time.

  Git doesn’t think of or store its data this way. Instead, Git thinks of its data
  more like a set of snapshots of a miniature filesystem. Every time you commit,
  or save the state of your project in Git, it basically takes a picture of what all
  your files look like at that moment and stores a reference to that snapshot. To
  be efficient, if files have not changed, Git doesn’t store the file again, just a link
  to the previous identical file it has already stored. Git thinks about its data more
  like a stream of snapshots.

  This makes Git more like a mini filesystem with some incredibly powerful tools built
  on top of it, rather than simply a VCS.

- Nearly Every Operation Is Local

  Most operations in Git only need local files and resources to operate – generally
  no information is needed from another computer on your network.

  This also means that there is very little you can’t do if you’re offline or off VPN.

- The Three States

      Git has three main states that
      your files can reside in: 

            modified,
            staged, and
            committed

      Modified means 
      that you have changed the file but have not committed it to your database yet. 

      Staged means that you have marked a modified file in its current version to go into
      your next commit snapshot.

      Committed means
      that the data is safely stored in your local database. (as a result of taking a snapshot)

  This leads us to the three main sections of a Git project: 

       the working directory,
       the staging area, and
       the Git directory

  The working directory is a single checkout of one version of the project.
  These files are pulled out of the compressed database in the Git directory and
  placed on disk for you to use or modify.

  The staging area is a file, generally contained in your Git directory, that
  stores information about what will go into your next commit. It’s sometimes re-
  ferred to as the “index”, but it’s also common to refer to it as the staging area.

  The Git directory is where Git stores the metadata and object database for
  your project. This is the most important part of Git, and it is what is copied
  when you clone a repository from another computer.

  The basic Git workflow goes something like this:

    1. You modify files in your working directory.
    2. You stage the files, adding snapshots of them to your staging area.          (git add)
    3. You do a commit, which takes the files as they are in the staging area and
       stores that snapshot permanently to your Git directory.                      (git commit)
    
    If a particular version of a file is in the Git directory, it’s considered committed. 
    If it has been modified and was added to the staging area, it is staged. And
    If it was changed since it was checked out but has not been staged, it is modified.

    Working Directory                   Staging Area                .git directdory (Repository)
    -----------------                   ------------                ----------------------------
          |                                   |                                    | 
          |<======================== Checkout the project =======================> |
          |                                   |                                    |
          | Stage Fixes ===================>  |                                    |
          | (git add)                         |                                    |
          |                                   | Commit ==========================> |
                                                (git commit)
- configuration

    - config files

        1. /etc/gitconfig file: Contains values for every user on the system and
                                all their repositories. 

                                If you pass the option --system to git config , it
                                reads and writes from this file specifically.

        2. ~/.gitconfig or ~/.config/git/config file: 

                                Specific to your user.

                                You can make Git read and write to this file specifically by passing the 
                                --global option.

        3. config file in the Git directory (that is, .git/config ) of whatever repos-
           itory you’re currently using: 

                                Specific to that single repository.

        Each level overrides values in the previous level, so values in .git/config
        trump those in /etc/gitconfig.


    - setting settings

        git config --global user.name "John Doe"
        git config --global user.email johndoe@example.com
        git config --global core.editor emacs

        Again, you need to do this only once if you pass the --global option, be-
        cause then Git will always use that information for anything you do on that sys-
        tem. If you want to override this with a different name or email address for spe-
        cific projects, you can run the command without the --global option when
        you’re in that project.

    - listing settings

        - git config --list

        You may see keys more than once, because Git reads the same key from dif-
        ferent files ( /etc/gitconfig and ~/.gitconfig , for example). In this case,
        Git uses the last value for each unique key it sees.

    You can also check what Git thinks a specific key’s value is by typing

        git config <key> :

        example:

            git config user.name
            John Doe

- Getting a Git Repository

  You can get a Git project using two main approaches. 

     The first takes an existing project or directory and imports it into Git. 
     The second clones an existing Git repository from another server.

  - Initializing a Repository in an Existing Directory

    If you’re starting to track an existing project in Git, you need to go to the
    project’s directory and type:

        git init

    This creates a new subdirectory named .git that contains all of your neces-
    sary repository files – a Git repository skeleton. At this point, nothing in your
    project is tracked yet

    If you want to start version-controlling existing files (as opposed to an empty
    directory), you should probably begin tracking those files and do an initial com-
    mit. You can accomplish that with a few git add commands that specify the
    files you want to track, followed by a git commit :

        git add *.c
        git add LICENSE
        git commit -m 'initial project version'

    At this point, you have a Git repository with tracked files and an initial commit.

- Cloning an Existing Repository

    If you want to get a copy of an existing Git repository – for example, a project
    you’d like to contribute to – the command you need is git clone . 

    If you’re fa-
    miliar with other VCS systems such as Subversion, you’ll notice that the com-
    mand is “clone” and not “checkout”. This is an important distinction – instead
    of getting just a working copy, Git receives a full copy of nearly all data that the
    server has. Every version of every file for the history of the project is pulled
    down by default when you run git clone .

    You clone a repository with git clone [url] . For example, if you want to
    clone the Git linkable library called libgit2, you can do so like this:

        git clone https://github.com/libgit2/libgit2

    That creates a directory named “libgit2”, initializes a .git directory inside it,
    pulls down all the data for that repository, and checks out a working copy of the
    latest version.

    If you want to clone the repository
    into a directory named something other than “libgit2”, you can specify that as
    the next command-line option:

        git clone https://github.com/libgit2/libgit2 mylibgit

    That command does the same thing as the previous one, but the target di-
    rectory is called mylibgit.

- Checking the Status of Your Files

    The main tool you use to determine which files are in which state is the git
    status command. If you run this command directly after a clone, you should
    see something like this:

        git status
        On branch master
        nothing to commit, working directory clean

        This means you have a clean working directory – in other words, there are no
        tracked and modified files. Git also doesn’t see any untracked files, or they
        would be listed here. Finally, the command tells you which branch you’re on
        and informs you that it has not diverged from the same branch on the server.
        For now, that branch is always “master”, which is the default

- git add

    git add is a multipurpose command – you use it to begin tracking
    new files, to stage files, and to do other things like marking merge-conflicted
    files as resolved. It may be helpful to think of it more as “add this content to the
    next commit” rather than “add this file to the project”

    Git stages a file exactly as it is when you run the git add command.

    If you modify a file after you run git add , you have
    to run git add again to stage the latest version of the file.

- Ignoring Files

    Often, you’ll have a class of files that you don’t want Git to automatically add or
    even show you as being untracked. These are generally automatically gener-
    ated files such as log files or files produced by your build system. In such cases,
    you can create a file listing patterns to match them named .gitignore . Here is
    an example .gitignore file:

        cat .gitignore
        *.[oa]
        *~

- Committing Your Changes

    Now that your staging area is set up the way you want it, you can commit your
    changes. Remember that anything that is still unstaged – any files you have cre-
    ated or modified that you haven’t run git add on since you edited them –
    won’t go into this commit. They will stay as modified files on your disk.

    Remember that the commit records the snapshot you set up in your staging
    area. Anything you didn’t stage is still sitting there modified; you can do anoth-
    er commit to add it to your history. Every time you perform a commit, you’re
    recording a snapshot of your project that you can revert to or compare to later.

    Skipping the Staging Area

        Although it can be amazingly useful for crafting commits exactly how you want
        them, the staging area is sometimes a bit more complex than you need in your
        workflow. If you want to skip the staging area, Git provides a simple shortcut.
        Adding the -a option to the git commit command makes Git automatically
        stage every file that is already tracked before doing the commit, letting you skip
        the git add part.

- Removing files

        git rm <filename>

    To remove a file from Git, you have to remove it from your tracked files (more
    accurately, remove it from your staging area) and then commit. The git rm
    command does that, and also removes the file from your working directory so
    you don’t see it as an untracked file the next time around.

    If you simply remove the file from your working directory, it shows up under
    the “Changed but not updated” (that is, unstaged) area of your git status
    output.

        $ rm PROJECTS.md
        $ git status
        Then, if you run git rm , it stages the file’s removal:
        $ git rm PROJECTS.md
        $ git status

        The next time you commit, the file will be gone and no longer tracked. If you
        modified the file and added it to the index already, you must force the removal
        with the -f option. This is a safety feature to prevent accidental removal of data
        that hasn’t yet been recorded in a snapshot and that can’t be recovered from
        Git.

    NOTE: can also do

        rm <filename>
        git add -A .

    Another useful thing you may want to do is to keep the file in your working
    tree but remove it from your staging area. In other words, you may want to
    keep the file on your hard drive but not have Git track it anymore. This is partic-
    ularly useful if you forgot to add something to your .gitignore file and acci-
    dentally staged it, like a large log file or a bunch of .a compiled files. To do this,
    use the --cached option:

        git rm --cached README

    You can pass files, directories, and file-glob patterns to the git rm command.

- Moving Files

    Unlike many other VCS systems, Git doesn’t explicitly track file movement. If
    you rename a file in Git, no metadata is stored in Git that tells it you renamed
    the file. However, Git is pretty smart about figuring that out after the fact – we’ll
    deal with detecting file movement a bit later.

    Thus it’s a bit confusing that Git has a mv command. If you want to rename a
    file in Git, you can run something like:

        git mv file_from file_to

    this is equivalent to running something like this:

    mv README.md README
    git rm README.md
    git add README

    Git figures out that it’s a rename implicitly, so it doesn’t matter if you re-
    name a file that way or with the mv command. The only real difference is that
    mv is one command instead of three – it’s a convenience function.

- Viewing the Commit History

    After you have created several commits, or if you have cloned a repository with
    an existing commit history, you’ll probably want to look back to see what has
    happened. The most basic and powerful tool to do this is

        git log

- Undoing Things

    At any stage, you may want to undo something. Here, we’ll review a few basic
    tools for undoing changes that you’ve made. Be careful, because you can’t al-
    ways undo some of these undos. This is one of the few areas in Git where you
    may lose some work if you do it wrong.

    One of the common undos takes place when you commit too early and pos-
    sibly forget to add some files, or you mess up your commit message. If you want
    to try that commit again, you can run commit with the --amend option:

        git commit --amend

    This command takes your staging area and uses it for the commit. If you’ve
    made no changes since your last commit (for instance, you run this command
    immediately after your previous commit), then your snapshot will look exactly
    the same, and all you’ll change is your commit message.

    The same commit-message editor fires up, but it already contains the mes-
    sage of your previous commit. You can edit the message the same as always,
    but it overwrites your previous commit.

    As an example, if you commit and then realize you forgot to stage the
    changes in a file you wanted to add to this commit, you can do something like
    this:

        git commit -m 'initial commit'
        git add forgotten_file
        git commit --amend

    You end up with a single commit – the second commit replaces the results of
    the first.

- Showing your remotes

    git remote
    git remote -v

    NOTE: Remote-tracking branches are references to the state of remote branches.
          They’re local references that you can’t move; they’re moved automatically for
          you whenever you do any network communication. Remote-tracking branches
          act as bookmarks to remind you where the branches in your remote reposito-
          ries were the last time you connected to them.

          They take the form (remote)/(branch) . For instance, if you wanted to see
          what the master branch on your origin remote looked like as of the last time
          you communicated with it, you would check the origin/master branch.

          To synchronize your work, you run a git fetch origin command. This
          command looks up which server “origin” is (in this case, it’s git.ourcompa-
          ny.com ), fetches any data from it that you don’t yet have, and updates your lo-
          cal database, moving your origin/master pointer to its new, more up-to-date
          position.

- Fetching and Pulling from Your Remotes

    As you just saw, to get data from your remote projects, you can run:

        git fetch [remote-name]

    The command goes out to that remote project and pulls down all the data
    from that remote project that you don’t have yet. After you do this, you should
    have references to all the branches from that remote, which you can merge in
    or inspect at any time.

    If you clone a repository, the command automatically adds that remote
    repository under the name “origin”. So, git fetch origin fetches any new
    work that has been pushed to that server since you cloned (or last fetched
    from) it. It’s important to note that the git fetch command pulls the data to
    your local repository – it doesn’t automatically merge it with any of your work
    or modify what you’re currently working on. You have to merge it manually into
    your work when you’re ready.

    If you have a branch set up to track a remote branch, you can use the git pull command to
    automatically fetch and then merge a remote branch into your current branch.
    This may be an easier or more comfortable workflow for you; and by default,
    the git clone command automatically sets up your local master branch to
    track the remote master branch (or whatever the default branch is called) on
    the server you cloned from. Running git pull generally fetches data from the
    server you originally cloned from and automatically tries to merge it into the
    code you’re currently working on.

    It’s important to note that when you do a fetch that brings down new
    remote-tracking branches, you don’t automatically have local, editable copies
    of them. In other words, in this case, you don’t have a new <branch_name> branch –
    you only have an origin/<branch_name> pointer that you can’t modify.
    To merge this work into your current working branch, you can run

        git merge origin/<branch_name>

    If you want your own serverfix branch that you can work on, you can base it off your
    remote-tracking branch:

        git checkout -b serverfix origin/serverfix

- git reset

    - Reset current HEAD to the specified state
    - can be used to unstage a file

    The git reset command is primarily used to undo things, as you can possibly
    tell by the verb. It moves around the HEAD pointer and optionally changes the
    index or staging area and can also optionally change the working directory if
    you use --hard . This final option makes it possible for this command to lose
    your work if used incorrectly, so make sure you understand it before using it.

- Pushing to Your Remotes

    When you have your project at a point that you want to share, you have to push
    it upstream. The command for this is simple: 

        git push [remote-name] [branch-name] 

    If you want to push your master branch to your origin server
    (again, cloning generally sets up both of those names for you automatically),
    then you can run this to push any commits you’ve done back up to the server:

        git push origin master

    This command works only if you cloned from a server to which you have
    write access and if nobody has pushed in the meantime. If you and someone
    else clone at the same time and they push upstream and then you push up-
    stream, your push will rightly be rejected. You’ll have to pull down their work
    first and incorporate it into yours before you’ll be allowed to push.

- Inspecting a Remote

    If you want to see more information about a particular remote, you can use the

        git remote show [remote-name] 

    command.

- Tagging

    Like most VCSs, Git has the ability to tag specific points in history as being im-
    portant. Typically people use this functionality to mark release points (v1.0, and
    so on).

    - git tag
      git tag <tag_name>
      git tag -a <tag_name> <commit_checksum>  (tag a commit after the fact)
      git tag -a <tag_name> -m "tag message"
      git show <tag_name>

    - Creating Tags

        Git uses two main types of tags: lightweight and annotated.

        A lightweight tag is very much like a branch that doesn’t change – it’s just a
        pointer to a specific commit.

            git tag <tag_name>

        Annotated tags, however, are stored as full objects in the Git database.
        They’re checksummed; contain the tagger name, email, and date; have a tag-
        ging message; and can be signed and verified with GNU Privacy Guard (GPG).
        It’s generally recommended that you create annotated tags so you can have all
        this information; but if you want a temporary tag or for some reason don’t want
        to keep the other information, lightweight tags are available too.

            git tag -a <tag_name> -m "tag message"

    - Sharing Tags

        By default, the git push command doesn’t transfer tags to remote servers.
        You will have to explicitly push tags to a shared server after you have created
        them. This process is just like sharing remote branches – you can run

            git push origin [tag_name]

        If you have a lot of tags that you want to push up at once, you can also use
        the --tags option to the git push command. This will transfer all of your tags
        to the remote server that are not already there.

            git push origin --tags

    - Checking out Tags

        You can’t really check out a tag in Git, since they can’t be moved around. If you
        want to put a version of your repository in your working directory that looks
        like a specific tag, you can create a new branch at a specific tag with 

            git checkout -b [branchname] [tagname]

- Git Aliases

    one little tip that can make your Git experience simpler, easier, and more familiar: aliases. 

    Git doesn’t automatically infer your command if you type it in partially. If
    you don’t want to type the entire text of each of the Git commands, you can
    easily set up an alias for each command using git config

        git config --global alias.co checkout
        git config --global alias.br branch
        git config --global alias.ci commit
        git config --global alias.st status

        git config --global alias.last 'log -1 HEAD'    (git last; see last commit easily)

- Branching

    Note: git clone gets full copy of everything; git branch doesn't, just generates a new pointer

    Branching means you diverge from the main line of development and continue to do work without
    messing with that main line.

    The way Git branches is incredibly lightweight, making branching operations nearly instan-
    taneous, and switching back and forth between branches generally just as fast.

    Git encourages workflows that branch and merge
    often, even multiple times in a day.

    Git doesn’t store data as a series of
    changesets or differences, but instead as a series of snapshots.

    When you make a commit, Git stores a commit object that contains a pointer
    to the snapshot of the content you staged. This object also contains the au-
    thor’s name and email, the message that you typed, and pointers to the commit
    or commits that directly came before this commit (its parent or parents): zero
    parents for the initial commit, one parent for a normal commit, and multiple
    parents for a commit that results from a merge of two or more branches.

    A branch in Git is simply a lightweight movable pointer to a commit.

    The default branch name in Git is master . As you start making commits,
    you’re given a master branch that points to the last commit you made.

    The “master” branch in Git is not a special branch. It is exactly like any
    other branch. The only reason nearly every repository has one is that the
    git init command creates it by default and most people don’t bother to
    change it.

    - Creating a New Branch

        What happens if you create a new branch? Well, doing so creates a new pointer
        for you to move around. Let’s say you create a new branch called testing. You
        do this with the git branch command:

            git branch testing

        This creates a new pointer to the same commit you’re currently on.

        How does Git know what branch you’re currently on? It keeps a special
        pointer called HEAD . Note that this is a lot different than the concept of HEAD in
        other VCSs you may be used to, such as Subversion or CVS. In Git, this is a point-
        er to the local branch you’re currently on. In this case, you’re still on master .
        The git branch command only created a new branch – it didn’t switch to that
        branch.

    - Switching Branches

        To switch to an existing branch, you run the git checkout command. Let’s
        switch to the new testing branch:

            git checkout testing

        This moves HEAD to point to the testing branch.

        SWITCHING BRANCHES CHANGES FILES IN YOUR WORKING DIRECTORY

            It’s important to note that when you switch branches in Git, files in your
            working directory will change. If you switch to an older branch, your
            working directory will be reverted to look like it did the last time you
            committed on that branch. If Git cannot do it cleanly, it will not let you
            switch at all.

    Because a branch in Git is in actuality a simple file that contains the 40 char-
    acter SHA-1 checksum of the commit it points to, branches are cheap to create
    and destroy. Creating a new branch is as quick and simple as writing 41 bytes to
    a file (40 characters and a newline).

    This is in sharp contrast to the way most older VCS tools branch, which in-
    volves copying all of the project’s files into a second directory. This can take
    several seconds or even minutes, depending on the size of the project, whereas
    in Git the process is always instantaneous. Also, because we’re recording the
    parents when we commit, finding a proper merge base for merging is automati-
    cally done for us and is generally very easy to do. These features help encour-
    age developers to create and use branches often.

    When you switch branches, Git resets your
    working directory to look like it did the last time you committed on that branch.
    It adds, removes, and modifies files automatically to make sure your working
    copy is what the branch looked like on your last commit to it.

- Tracking Branches

    Checking out a local branch from a remote-tracking branch automatically cre-
    ates what is called a “tracking branch” (or sometimes an “upstream branch”).

    Tracking branches are local branches that have a direct relationship to a re-
    mote branch. If you’re on a tracking branch and type 

        git pull

    Git automatically knows which server to fetch from and branch to merge into.

    When you clone a repository, it generally automatically creates a master
    branch that tracks origin/master . However, you can set up other tracking
    branches if you wish – ones that track branches on other remotes, or don’t
    track the master branch. The simple case is the example:

        git checkout -b [branch] [remotename]/[branch]

    This is a common enough operation that git provides the --track shorthand:

        git checkout --track origin/branch_name

    In fact, this is so common that there’s even a shortcut for that shortcut. If the
    branch name you’re trying to checkout (a) doesn’t exist and (b) exactly matches
    a name on only one remote, Git will create a tracking branch for you:

        git checkout branch_name

    To set up a local branch with a different name than the remote branch, you
    can easily use the first version with a different local branch name:

        git checkout -b bn origin/branch_name

    Now, your local branch bn will automatically pull from origin/branch_name .

    If you already have a local branch and want to set it to a remote branch you
    just pulled down, or want to change the upstream branch you’re tracking, you
    can use the -u or --set-upstream-to option to git branch to explicitly set
    it at any time.

        git branch -u origin/branch_name

- git fetch vs git pull

    In the simplest terms, git pull does a git fetch followed by a git merge.

    You can do a git fetch at any time to update your remote-tracking branches under refs/remotes/<remote>/.

    This operation never changes any of your own local branches under refs/heads, and is safe to do without
    changing your working copy.

    I have even heard of people running git fetch periodically in a cron job in the background
    (although I wouldn’t recommend doing this).

    A git pull is what you would do to bring a local branch up-to-date with its remote version, 
    while also updating your other remote-tracking branches.

- Merging

    git merge <branch_name>     (merges branch_name into current branch)

    - Preparing to merge

        Before performing a merge there are a couple of preparation steps to take to ensure
        the merge goes smoothly.

        - Confirm the receiving branch

        - Execute git status to ensure that HEAD is pointing to the correct merge-receiving branch. 
          If needed, execute 

                git checkout <receiving> 

          to switch to the receiving branch.

        - Fetch latest remote commits

            - Make sure the receiving branch and the merging branch are up-to-date with the latest remote changes.
              
                - Checkout the merging branch (usually the local repository: git checkout <merging branch>)
                - Execute "git fetch" to pull the latest remote commits for the "merging branch". 
                - Checkout the receiving branch (git checkout <receiving_branch>)
                - Ensure the receiving branch has the latest updates by executing "git pull".

    - Merging

        Once the previously discussed "preparing to merge" steps have been taken a merge can be initiated by
        executing git merge <branch name> where <branch name> is the name of the branch that will be merged
        into the receiving branch.

    - How conflicts are presented

        Use git status for more info

        NOTE: only have to change the conflicting file in the receiving branch

        When Git encounters a conflict during a merge, It will edit the content of the affected files with
        visual indicators that mark both sides of the conflicted content. These visual markers are: <<<<<<<,
        =======, and >>>>>>>. Its helpful to search a project for these indicators during a merge to find
        where conflicts need to be resolved.

        Generally the content before the ======= marker is the receiving branch and the part after is the
        merging branch.

        Once you've identified conflicting sections, you can go in and fix up the merge to your liking. 
        When you're ready to finish the merge, all you have to do is run git add on the conflicted file(s)
        to tell Git they're resolved. Then, you run a normal git commit to generate the merge commit. It’s
        the exact same process as committing an ordinary snapshot, which means it’s easy for normal developers
        to manage their own merges.

        Should you decide not to use a merge tool and instead clean up the file in your editor, you'll have
        to mark the file as resolved by hand (by executing "git add <filename>").
        Finally, after solving all conflicts, a merge conflict situation needs to be concluded by a regular 
        commit.

- Rebasing

    git rebase <branch_name>

    Another way, beside merge, to integrate changes from one branch into another

    With the rebase command, you can take all the changes that were committed
    on one branch and replay them on another one.

    It works by going to the common ancestor of the two branches (the one
    you’re on and the one you’re rebasing onto), getting the diff introduced by each
    commit of the branch you’re on, saving those diffs to temporary files, resetting
    the current branch to the same commit as the branch you are rebasing onto,
    and finally applying each change in turn.

    Rebasing makes for a cleaner history. If you examine
    the log of a rebased branch, it looks like a linear history: it appears that all the
    work happened in series, even when it originally happened in parallel.

    Often, you’ll do this to make sure your commits apply cleanly on a remote
    branch – perhaps in a project to which you’re trying to contribute but that you
    don’t maintain. In this case, you’d do your work in a branch and then rebase
    your work onto origin/master when you were ready to submit your patches
    to the main project. That way, the maintainer doesn’t have to do any integra-
    tion work – just a fast-forward or a clean apply.

    Note that the snapshot pointed to by the final commit you end up with,
    whether it’s the last of the rebased commits for a rebase or the final merge
    commit after a merge, is the same snapshot – it’s only the history that is differ-
    ent. Rebasing replays changes from one line of work onto another in the order
    they were introduced, whereas merging takes the endpoints and merges them
    together.

    - Perils of Rebasing

        Ahh, but the bliss of rebasing isn’t without its drawbacks, which can be sum-
        med up in a single line:

            Do not rebase commits that exist outside your repository.

        When you rebase stuff, you’re abandoning existing commits and creating
        new ones that are similar but different. If you push commits somewhere and
        others pull them down and base work on them, and then you rewrite those
        commits with git rebase and push them up again, your collaborators will
        have to re-merge their work and things will get messy when you try to pull their
        work back into yours.

        If you treat rebasing as a way to clean up and work with commits before you
        push them, and if you only rebase commits that have never been available pub-
        licly, then you’ll be fine. If you rebase commits that have already been pushed
        publicly, and people may have based work on those commits, then you may be
        in for some frustrating trouble, and the scorn of your teammates.

        If you or a partner does find it necessary at some point, make sure everyone
        knows to run git pull --rebase to try to make the pain after it happens a
        little bit simpler.

        In general the way to get the best of both worlds is to rebase local changes
        you’ve made but haven’t shared yet before you push them in order to clean up
        your story, but never rebase anything you’ve pushed somewhere.

    git-rebase: Reapply all the commit from your branch to the tip of another branch.

    The most important word here is “reapply” because a rebase is not simply a ctrl-x/ctrl-v
    of a branch to another. A rebase will sequentially take all the commit from the branch 
    you’re in, and reapply them to the destination. This behavior has 2 main implications:

        By reapplying commits git creates new ones. Those new commits, even if they bring the
        same set of change will be treated as completely different and independent by git.

        Git rebase reapplies commits, and does not destroy the old ones. It means that even 
        after a rebase, your old commits will still be in the /objects folder in your .git 
        directory. 

        The feature branch has completely new commits. As said before, same set of changes,
        but completely different objects from the git point of view. And you can also see that
        previous commits are not destroyed. They are simply not directly accessible.

        No one shall rebase a shared (public) branch” — Everyone about rebase

        You have probably came across that rule, maybe phrased differently. For those who haven’t,
        this rule is quite simple. 

            Never, NEVER, **NEVER, **rebase a shared (public) branch. 

        By shared branch I mean a branch that exists on the distant repository and that
        other people on your team could pull.

Maintaining a Project
---------------------

    When you’re thinking of integrating new work, it’s generally a good idea to try it
    out in a topic branch – a temporary branch specifically made to try out that
    new work. This way, it’s easy to tweak a patch individually and leave it if it’s not
    working until you have time to come back to it. If you create a simple branch
    name based on the theme of the work you’re going to try, such as 

        ruby_client 

    or something similarly descriptive, you can easily remember it if you have
    to abandon it for a while and come back later. The maintainer of the Git project
    tends to namespace these branches as well – such as

         sc/ruby_client

    here sc is short for the person who contributed the work. As you’ll remember, you
    can create the branch based off your master branch like this:

        git branch sc/ruby_client master

    Or, if you want to also switch to it immediately, you can use the  checkout -b option:

        git checkout -b sc/ruby_client master

    Now you’re ready to add your contributed work into this topic branch and
    determine if you want to merge it into your longer-term branches.

    - Can apply patches from email

    - can apply changes via provided remote branches

        Checking Out Remote Branches

            If your contribution came from a Git user who set up their own repository, push-
            ed a number of changes into it, and then sent you the URL to the repository and
            the name of the remote branch the changes are in, you can add them as a re-
            mote and do merges locally.

            For instance, if Jessica sends you an email saying that she has a great new
            feature in the ruby-client branch of her repository, you can test it by adding
            the remote and checking out that branch locally:

                git remote add jessica git://github.com/jessica/myproject.git
                git fetch jessica
                git checkout -b rubyclient jessica/ruby-client

            If she emails you again later with another branch containing another great
            feature, you can fetch and check out because you already have the remote set-
            up.

        If you aren’t working with a person consistently but still want to pull from
        them in this way, you can provide the URL of the remote repository to the git
        pull command. This does a one-time pull and doesn’t save the URL as a re-
        mote reference:

            $ git pull https://github.com/onetimeguy/project
            From https://github.com/onetimeguy/project
             * branch    HEAD    -> FETCH_HEAD
            Merge made by recursive.

        See book for more details on further steps in the new contribution assessment process

    - MERGING WORKFLOWS

        One simple workflow merges your work into your master branch. In this sce-
        nario, you have a master branch that contains basically stable code. When you
        have work in a topic branch that you’ve done or that someone has contributed
        and you’ve verified, you merge it into your master branch, delete the topic
        branch, and then continue the process.

        If you have a more important project, you might want to use a two-phase
        merge cycle. In this scenario, you have two long-running branches, master and
        develop , in which you determine that master is updated only when a very sta-
        ble release is cut and all new code is integrated into the develop branch. You
        regularly push both of these branches to the public repository. Each time you
        have a new topic branch to merge in, you merge it into develop; then, when you
        tag a release, you fast-forward master to wherever the now-stable develop branch is

        This way, when people clone your project’s repository, they can either check
        out master to build the latest stable version and keep up to date on that easily,
        or they can check out develop, which is the more cutting-edge stuff. You can
        also continue this concept, having an integrate branch where all the work is
        merged together. Then, when the codebase on that branch is stable and passes
        tests, you merge it into a develop branch; and when that has proven itself sta-
        ble for a while, you fast-forward your master branch.

- Stashing

    Often, when you’ve been working on part of your project, things are in a messy
    state and you want to switch branches for a bit to work on something else. The
    problem is, you don’t want to do a commit of half-done work just so you can get
    back to this point later. The answer to this issue is the git stash command.

       git stash

    Stashing takes the dirty state of your working directory – that is, your modi-
    fied tracked files and staged changes – and saves it on a stack of unfinished
    changes that you can reapply at any time.

    Say you want to switch branches, but you don’t want to commit what
    you’ve been working on yet; so you’ll stash the changes. To push a new stash
    onto your stack, run 

        git stash 

    or 

        git stash save

    (To restore type "git stash apply")


    Your working directory is clean:

        git status
        # On branch master
        nothing to commit, working directory clean

    At this point, you can easily switch branches and do work elsewhere; your
    changes are stored on your stack. To see which stashes you’ve stored, you can

        git stash list

    Having a clean working directory and applying it on the same branch aren’t
    necessary to successfully apply a stash. You can save a stash on one branch,
    switch to another branch later, and try to reapply the changes. You can also
    have modified and uncommitted files in your working directory when you apply
    a stash – Git gives you merge conflicts if anything no longer applies cleanly.

    To reapply stash

        git stash apply

    The changes to your files are reapplied, but the any files you staged before
    aren't restaged. To do that, you must run the git stash apply command
    with a --index option to tell the command to try to reapply the staged
    changes. If you run this instead, you'll get back to your original
    position

        git stash apply --index

    You can also run "git stash pop" to apply the stash and then immediately
    drop it from your stack.

        git stash pop

    There are a few stash variants that may also be helpful. The first option that is
    quite popular is the --keep-index option to the stash save command. This
    tells Git to not stash anything that you’ve already staged with the git add
    command.
	
        git stash --keep-index

    This can be really helpful if you’ve made a number of changes but want to
    only commit some of them and then come back to the rest of the changes at a
    later time.

    Another common thing you may want to do with stash is to stash the un-
    tracked files as well as the tracked ones. By default, git stash will only store
    files that are already in the index. If you specify --include-untracked or -u ,
    Git will also stash any untracked files you have created.

        git stash -u

    Finally, if you specify the --patch flag, Git will not stash everything that is
    modified but will instead prompt you interactively which of the changes you
    would like to stash and which you would like to keep in your working directory.

        git stash --patch

    - Creating a Branch from a Stash

        If you stash some work, leave it there for a while, and continue on the branch
        from which you stashed the work, you may have a problem reapplying the
        work. If the apply tries to modify a file that you’ve since modified, you’ll get a
        merge conflict and will have to try to resolve it. If you want an easier way to test
        the stashed changes again, you can run

            git stash branch

    which creates a new branch for you, checks out the commit you were on when you stashed your
    work, reapplies your work there, and then drops the stash if it applies success-
    fully

        $ git stash branch testchanges
        Switched to a new branch "testchanges"
        # On branch testchanges

- Cleaning your Working Directory

    Finally, you may not want to stash some work or files in your working directory,
    but simply get rid of them. The 

        git clean 

    command will do this for you. Some common reasons for this might be to remove cruft
    that has been generated by merges or external tools or to remove build artifacts in
    order to run a clean build.

    You’ll want to be pretty careful with this command, since it’s designed to re-
    move files from your working directory that are not tracked. If you change your
    mind, there is often no retrieving the content of those files. A safer option is to
    run git 

        stash --all

    to remove everything but save it in a stash.
    
    Assuming you do want to remove cruft files or clean your working directory,
    you can do so with git clean . To remove all the untracked files in your work-
    ing directory, you can run

        git clean -f -d

    which removes any files and also any subdirectories that become empty as a result. 
    The -f means force or “really do this”.

    If you ever want to see what it would do, you can run the command with the
    -n option, which means “do a dry run and tell me what you would have re-
    moved”.

        git clean -d -n

    By default, the git clean command will only remove untracked files that
    are not ignored. Any file that matches a pattern in your .gitignore or other
    ignore files will not be removed. If you want to remove those files too, such as
    to remove all .o files generated from a build so you can do a fully clean build,
    you can add a -x to the clean command.

- Searching
    With just about any size codebase, you’ll often need to find where a function is
    called or defined, or find the history of a method. Git provides a couple of useful
    tools for looking through the code and commits stored in its database quickly
    and easily. We’ll go through a few of them.

    Git Grep

        The git grep command has a few advantages over normal searching com-
        mands like grep and ack . The first is that it’s really fast, the second is that you
        can search through any tree in Git, not just the working directory. For example, it
        can for terms in an older version of the Git source code, not the version that is
        currently checked out.

    Git Log Searching

        Perhaps you’re looking not for where a term exists, but when it existed or was
        introduced. The git log command has a number of powerful tools for finding
        specific commits by the content of their messages or even the content of the
        diff they introduce.

Rewriting History

    Many times, when working with Git, you may want to revise your commit histo-
    ry for some reason. One of the great things about Git is that it allows you to
    make decisions at the last possible moment. You can decide what files go into
    which commits right before you commit with the staging area, you can decide
    that you didn’t mean to be working on something yet with the stash command,
    and you can rewrite commits that already happened so they look like they hap-
    pened in a different way. This can involve changing the order of the commits,
    changing messages or modifying files in a commit, squashing together or split-
    ting apart commits, or removing commits entirely – all before you share your
    work with others.

    You can make your commit history look the way you want before you share it
    With others.

    Changing the Last Commit

        Changing your last commit is probably the most common rewriting of history
        that you’ll do. You’ll often want to do two basic things to your last commit:
        change the commit message, or change the snapshot you just recorded by
        adding, changing and removing files.

        If you only want to modify your last commit message, it’s very simple:

            git commit --amend

    If you’ve committed and then you want to change the snapshot you commit-
    ted by adding or changing files, possibly because you forgot to add a newly cre-
    ated file when you originally committed, the process works basically the same
    way. You stage the changes you want by editing a file and running git add on
    it or git rm to a tracked file, and the subsequent

        git commit --amend 

    takes your current staging area and makes it the snapshot for the new commit.
    You need to be careful with this technique because amending changes the
    SHA-1 of the commit. It’s like a very small rebase – don’t amend your last com-
    mit if you’ve already pushed it.

- The Three Trees

    Git as a system manages and manipulates three trees in its normal operation:

        Tree                Role    
        ----                ----
        HEAD                Last commit snapshot, next parent
        Index               Proposed next commit snapshot
        Working Directory   Sandbox

    THE HEAD

        HEAD is the pointer to the current branch reference, which is in turn a pointer to
        the last commit made on that branch. That means HEAD will be the parent of
        the next commit that is created. It’s generally simplest to think of HEAD as the
        snapshot of your last commit.

    THE INDEX

        The Index is your proposed next commit. We’ve also been referring to this concept as
        Git’s “Staging Area” as this is what Git looks at when you run git commit .

        Git populates this index with a list of all the file contents that were last
        checked out into your working directory and what they looked like when they
        were originally checked out. You then replace some of those files with new
        versions of them, and git commit converts that into the tree for a new commit.

    THE WORKING DIRECTORY

        Finally, you have your working directory. The other two trees store their content
        in an efficient but inconvenient manner, inside the .git folder. The Working Di-
        rectory unpacks them into actual files, which makes it much easier for you to
        edit them. Think of the Working Directory as a sandbox, where you can try
        changes out before committing them to your staging area (index) and then to
        history.


- Git in Bash

    If you’re a Bash user, you can tap into some of your shell’s features to make
    your experience with Git a lot friendlier. Git actually ships with plugins for sever-
    al shells, but it’s not turned on by default.

    First, you need to get a copy of the contrib/completion/git-
    completion.bash file out of the Git source code. Copy it somewhere handy,
    like your home directory, and add this to your .bashrc :

        . ~/git-completion.bash

    Once that’s done, change your directory to a git repository, and type:

        git chec<tab>
    
    and Bash will auto-complete to git checkout . This works with all of Git’s
    subcommands, command-line parameters, and remotes and ref names where
    appropriate.

    It’s also useful to customize your prompt to show information about the cur-
    rent directory’s Git repository. This can be as simple or complex as you want,
    but there are generally a few key pieces of information that most people want,
    like the current branch, and the status of the working directory. To add these to
    your prompt, just copy the contrib/completion/git-prompt.sh file from
    Git’s source repository to your home directory, add some variables to
    your .bashrc (see documentation)

GitHub
------

- The way that GitHub maps your Git commits to your user is by email address.

- Forking Projects

    If you want to contribute to an existing project to which you don’t have push
    access, you can “fork” the project. What this means is that GitHub will make a
    copy of the project that is entirely yours; it lives in your user’s namespace, and
    you can push to it.

    This way, projects don’t have to worry about adding users as collaborators
    to give them push access. People can fork a project, push to it, and contribute
    their changes back to the original repository by creating what’s called a 
    Pull Request,

    Historically, the term “fork” has been somewhat negative in context,
    meaning that someone took an open source project in a different direc-
    tion, sometimes creating a competing project and splitting the contribu-
    tors. In GitHub, a “fork” is simply the same project in your own name-
    space, allowing you to make changes to a project publicly as a way to
    contribute in a more open manner.

- NOT ONLY FORKS

    It’s important to note that you can also open a Pull Request between two
    branches in the same repository. If you’re working on a feature with
    someone and you both have write access to the project, you can push a
    topic branch to the repository and open a Pull Request on it to the master
    branch of that same project to initiate the code review and discussion
    process. No forking necessary.


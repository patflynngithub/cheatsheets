
Modified: 05/06/19


Git Cheatsheet
==============

git config

git add -A .
git commit -m "Final revision before sending out Lesson 1"
git push origin master

git commit --amend

git fetch
git pull   (combo of git fetch and git merge)
git reset
git rm
git mv
git clean
git rebase

git status
git log
git remote
git remote add
git remote show
git diff     (git difftool)
git show
git shortlog

git branch branch-name
git branch -d branch-name
git checkout branch-name
git checkout -b <branch_name>
git checkout -- <file>         (to discard changes in working directory)


git merge <filename>    (git mergetool)
git stash
git tag

git help




SETUP
-----

	git config --global user.name "Firstname Lastname" (whatever yours is)
	git config --global user.email "your@email.address" (whatever yours is)
	git config --global credential.helper 'cache --timeout=3600'
	git config --global core.editor "gedit -w -s"  (or whatever text editor you use)

    git init
	git clone https://github.com/your-github-account-name/pycnumanal-lessons

-------------------------------------------------------

- Git is a DVCS

    Distributed Version Control System


- The major difference between Git and any other VCS (Subversion and friends
  included) is the way Git thinks about its data. Conceptually, most other systems
  store information as a list of file-based changes. These systems (CVS, Subver-
  sion, Perforce, Bazaar, and so on) think of the information they keep as a set of
  files and the changes made to each file over time.

  Git doesn’t think of or store its data this way. Instead, Git thinks of its data
  more like a set of snapshots of a miniature filesystem. Every time you commit,
  or save the state of your project in Git, it basically takes a picture of what all
  your files look like at that moment and stores a reference to that snapshot. To
  be efficient, if files have not changed, Git doesn’t store the file again, just a link
  to the previous identical file it has already stored. Git thinks about its data more
  like a stream of snapshots.

  This makes Git more like a mini filesystem with some incredibly powerful tools built
  on top of it, rather than simply a VCS.

- Nearly Every Operation Is Local

  Most operations in Git only need local files and resources to operate – generally
  no information is needed from another computer on your network.

  This also means that there is very little you can’t do if you’re offline or off VPN.

- The Three States

      Git has three main states that
      your files can reside in: 

            modified,
            staged, and
            committed

      Modified means 
      that you have changed the file but have not committed it to your database yet. 

      Staged means that you have marked a modified file in its current version to go into
      your next commit snapshot.

      Committed means
      that the data is safely stored in your local database. (as a result of taking a snapshot)

  This leads us to the three main sections of a Git project: 

       the working directory,
       the staging area, and
       the Git directory

  The working directory is a single checkout of one version of the project.
  These files are pulled out of the compressed database in the Git directory and
  placed on disk for you to use or modify.

  The staging area is a file, generally contained in your Git directory, that
  stores information about what will go into your next commit. It’s sometimes re-
  ferred to as the “index”, but it’s also common to refer to it as the staging area.

  The Git directory is where Git stores the metadata and object database for
  your project. This is the most important part of Git, and it is what is copied
  when you clone a repository from another computer.

  The basic Git workflow goes something like this:

    1. You modify files in your working directory.
    2. You stage the files, adding snapshots of them to your staging area.          (git add)
    3. You do a commit, which takes the files as they are in the staging area and
       stores that snapshot permanently to your Git directory.                      (git commit)
    
    If a particular version of a file is in the Git directory, it’s considered committed. 
    If it has been modified and was added to the staging area, it is staged. And
    If it was changed since it was checked out but has not been staged, it is modified.

    Working Directory                   Staging Area                .git directdory (Repository)
    -----------------                   ------------                ----------------------------
          |                                   |                                    | 
          |<======================== Checkout the project =======================> |
          |                                   |                                    |
          | Stage Fixes ===================>  |                                    |
          | (git add)                         |                                    |
          |                                   | Commit ==========================> |
                                                (git commit)
- configuration

    - config files

        1. /etc/gitconfig file: Contains values for every user on the system and
                                all their repositories. 

                                If you pass the option --system to git config , it
                                reads and writes from this file specifically.

        2. ~/.gitconfig or ~/.config/git/config file: 

                                Specific to your user.

                                You can make Git read and write to this file specifically by passing the 
                                --global option.

        3. config file in the Git directory (that is, .git/config ) of whatever repos-
           itory you’re currently using: 

                                Specific to that single repository.

        Each level overrides values in the previous level, so values in .git/config
        trump those in /etc/gitconfig.


    - setting settings

        git config --global user.name "John Doe"
        git config --global user.email johndoe@example.com
        git config --global core.editor emacs

        Again, you need to do this only once if you pass the --global option, be-
        cause then Git will always use that information for anything you do on that sys-
        tem. If you want to override this with a different name or email address for spe-
        cific projects, you can run the command without the --global option when
        you’re in that project.

    - listing settings

        - git config --list

        You may see keys more than once, because Git reads the same key from dif-
        ferent files ( /etc/gitconfig and ~/.gitconfig , for example). In this case,
        Git uses the last value for each unique key it sees.

    You can also check what Git thinks a specific key’s value is by typing

        git config <key> :

        example:

            git config user.name
            John Doe

- Getting a Git Repository

  You can get a Git project using two main approaches. 

     The first takes an existing project or directory and imports it into Git. 
     The second clones an existing Git repository from another server.

  - Initializing a Repository in an Existing Directory

    If you’re starting to track an existing project in Git, you need to go to the
    project’s directory and type:

        git init

    This creates a new subdirectory named .git that contains all of your neces-
    sary repository files – a Git repository skeleton. At this point, nothing in your
    project is tracked yet

    If you want to start version-controlling existing files (as opposed to an empty
    directory), you should probably begin tracking those files and do an initial com-
    mit. You can accomplish that with a few git add commands that specify the
    files you want to track, followed by a git commit :

        git add *.c
        git add LICENSE
        git commit -m 'initial project version'

    At this point, you have a Git repository with tracked files and an initial commit.

- Cloning an Existing Repository

    If you want to get a copy of an existing Git repository – for example, a project
    you’d like to contribute to – the command you need is git clone . 

    If you’re fa-
    miliar with other VCS systems such as Subversion, you’ll notice that the com-
    mand is “clone” and not “checkout”. This is an important distinction – instead
    of getting just a working copy, Git receives a full copy of nearly all data that the
    server has. Every version of every file for the history of the project is pulled
    down by default when you run git clone .

    You clone a repository with git clone [url] . For example, if you want to
    clone the Git linkable library called libgit2, you can do so like this:

        git clone https://github.com/libgit2/libgit2

    That creates a directory named “libgit2”, initializes a .git directory inside it,
    pulls down all the data for that repository, and checks out a working copy of the
    latest version.

    If you want to clone the repository
    into a directory named something other than “libgit2”, you can specify that as
    the next command-line option:

        git clone https://github.com/libgit2/libgit2 mylibgit

    That command does the same thing as the previous one, but the target di-
    rectory is called mylibgit.

- Checking the Status of Your Files

    The main tool you use to determine which files are in which state is the git
    status command. If you run this command directly after a clone, you should
    see something like this:

        git status
        On branch master
        nothing to commit, working directory clean

        This means you have a clean working directory – in other words, there are no
        tracked and modified files. Git also doesn’t see any untracked files, or they
        would be listed here. Finally, the command tells you which branch you’re on
        and informs you that it has not diverged from the same branch on the server.
        For now, that branch is always “master”, which is the default

- git add

    git add is a multipurpose command – you use it to begin tracking
    new files, to stage files, and to do other things like marking merge-conflicted
    files as resolved. It may be helpful to think of it more as “add this content to the
    next commit” rather than “add this file to the project”

    Git stages a file exactly as it is when you run the git add command.

    If you modify a file after you run git add , you have
    to run git add again to stage the latest version of the file.

- Ignoring Files

    Often, you’ll have a class of files that you don’t want Git to automatically add or
    even show you as being untracked. These are generally automatically gener-
    ated files such as log files or files produced by your build system. In such cases,
    you can create a file listing patterns to match them named .gitignore . Here is
    an example .gitignore file:

        cat .gitignore
        *.[oa]
        *~

- Committing Your Changes

    Now that your staging area is set up the way you want it, you can commit your
    changes. Remember that anything that is still unstaged – any files you have cre-
    ated or modified that you haven’t run git add on since you edited them –
    won’t go into this commit. They will stay as modified files on your disk.

    Remember that the commit records the snapshot you set up in your staging
    area. Anything you didn’t stage is still sitting there modified; you can do anoth-
    er commit to add it to your history. Every time you perform a commit, you’re
    recording a snapshot of your project that you can revert to or compare to later.

    Skipping the Staging Area

        Although it can be amazingly useful for crafting commits exactly how you want
        them, the staging area is sometimes a bit more complex than you need in your
        workflow. If you want to skip the staging area, Git provides a simple shortcut.
        Adding the -a option to the git commit command makes Git automatically
        stage every file that is already tracked before doing the commit, letting you skip
        the git add part.

- Removing files

        git rm <filename>

    To remove a file from Git, you have to remove it from your tracked files (more
    accurately, remove it from your staging area) and then commit. The git rm
    command does that, and also removes the file from your working directory so
    you don’t see it as an untracked file the next time around.

    If you simply remove the file from your working directory, it shows up under
    the “Changed but not updated” (that is, unstaged) area of your git status
    output.

        $ rm PROJECTS.md
        $ git status
        Then, if you run git rm , it stages the file’s removal:
        $ git rm PROJECTS.md
        $ git status

        The next time you commit, the file will be gone and no longer tracked. If you
        modified the file and added it to the index already, you must force the removal
        with the -f option. This is a safety feature to prevent accidental removal of data
        that hasn’t yet been recorded in a snapshot and that can’t be recovered from
        Git.

    NOTE: can also do

        rm <filename>
        git add -A .

    Another useful thing you may want to do is to keep the file in your working
    tree but remove it from your staging area. In other words, you may want to
    keep the file on your hard drive but not have Git track it anymore. This is partic-
    ularly useful if you forgot to add something to your .gitignore file and acci-
    dentally staged it, like a large log file or a bunch of .a compiled files. To do this,
    use the --cached option:

        git rm --cached README

    You can pass files, directories, and file-glob patterns to the git rm command.

- Moving Files

    Unlike many other VCS systems, Git doesn’t explicitly track file movement. If
    you rename a file in Git, no metadata is stored in Git that tells it you renamed
    the file. However, Git is pretty smart about figuring that out after the fact – we’ll
    deal with detecting file movement a bit later.

    Thus it’s a bit confusing that Git has a mv command. If you want to rename a
    file in Git, you can run something like:

        git mv file_from file_to

    this is equivalent to running something like this:

    mv README.md README
    git rm README.md
    git add README

    Git figures out that it’s a rename implicitly, so it doesn’t matter if you re-
    name a file that way or with the mv command. The only real difference is that
    mv is one command instead of three – it’s a convenience function.

- Viewing the Commit History

    After you have created several commits, or if you have cloned a repository with
    an existing commit history, you’ll probably want to look back to see what has
    happened. The most basic and powerful tool to do this is

        git log

- Undoing Things

    At any stage, you may want to undo something. Here, we’ll review a few basic
    tools for undoing changes that you’ve made. Be careful, because you can’t al-
    ways undo some of these undos. This is one of the few areas in Git where you
    may lose some work if you do it wrong.

    One of the common undos takes place when you commit too early and pos-
    sibly forget to add some files, or you mess up your commit message. If you want
    to try that commit again, you can run commit with the --amend option:

        git commit --amend

    This command takes your staging area and uses it for the commit. If you’ve
    made no changes since your last commit (for instance, you run this command
    immediately after your previous commit), then your snapshot will look exactly
    the same, and all you’ll change is your commit message.

    The same commit-message editor fires up, but it already contains the mes-
    sage of your previous commit. You can edit the message the same as always,
    but it overwrites your previous commit.

    As an example, if you commit and then realize you forgot to stage the
    changes in a file you wanted to add to this commit, you can do something like
    this:

        git commit -m 'initial commit'
        git add forgotten_file
        git commit --amend

    You end up with a single commit – the second commit replaces the results of
    the first.

- Showing your remotes

    git remote
    git remote -v

    NOTE: Remote-tracking branches are references to the state of remote branches.
          They’re local references that you can’t move; they’re moved automatically for
          you whenever you do any network communication. Remote-tracking branches
          act as bookmarks to remind you where the branches in your remote reposito-
          ries were the last time you connected to them.

          They take the form (remote)/(branch) . For instance, if you wanted to see
          what the master branch on your origin remote looked like as of the last time
          you communicated with it, you would check the origin/master branch.

          To synchronize your work, you run a git fetch origin command. This
          command looks up which server “origin” is (in this case, it’s git.ourcompa-
          ny.com ), fetches any data from it that you don’t yet have, and updates your lo-
          cal database, moving your origin/master pointer to its new, more up-to-date
          position.

- Fetching and Pulling from Your Remotes

    As you just saw, to get data from your remote projects, you can run:

        git fetch [remote-name]

    The command goes out to that remote project and pulls down all the data
    from that remote project that you don’t have yet. After you do this, you should
    have references to all the branches from that remote, which you can merge in
    or inspect at any time.

    If you clone a repository, the command automatically adds that remote
    repository under the name “origin”. So, git fetch origin fetches any new
    work that has been pushed to that server since you cloned (or last fetched
    from) it. It’s important to note that the git fetch command pulls the data to
    your local repository – it doesn’t automatically merge it with any of your work
    or modify what you’re currently working on. You have to merge it manually into
    your work when you’re ready.

    If you have a branch set up to track a remote branch, you can use the git pull command to
    automatically fetch and then merge a remote branch into your current branch.
    This may be an easier or more comfortable workflow for you; and by default,
    the git clone command automatically sets up your local master branch to
    track the remote master branch (or whatever the default branch is called) on
    the server you cloned from. Running git pull generally fetches data from the
    server you originally cloned from and automatically tries to merge it into the
    code you’re currently working on.

    It’s important to note that when you do a fetch that brings down new
    remote-tracking branches, you don’t automatically have local, editable copies
    of them. In other words, in this case, you don’t have a new <branch_name> branch –
    you only have an origin/<branch_name> pointer that you can’t modify.
    To merge this work into your current working branch, you can run

        git merge origin/<branch_name>

    If you want your own serverfix branch that you can work on, you can base it off your
    remote-tracking branch:

        git checkout -b serverfix origin/serverfix

- git reset

    - Reset current HEAD to the specified state
    - can be used to unstage a file

    The git reset command is primarily used to undo things, as you can possibly
    tell by the verb. It moves around the HEAD pointer and optionally changes the
    index or staging area and can also optionally change the working directory if
    you use --hard . This final option makes it possible for this command to lose
    your work if used incorrectly, so make sure you understand it before using it.

- Pushing to Your Remotes

    When you have your project at a point that you want to share, you have to push
    it upstream. The command for this is simple: 

        git push [remote-name] [branch-name] 

    If you want to push your master branch to your origin server
    (again, cloning generally sets up both of those names for you automatically),
    then you can run this to push any commits you’ve done back up to the server:

        git push origin master

    This command works only if you cloned from a server to which you have
    write access and if nobody has pushed in the meantime. If you and someone
    else clone at the same time and they push upstream and then you push up-
    stream, your push will rightly be rejected. You’ll have to pull down their work
    first and incorporate it into yours before you’ll be allowed to push.

- Inspecting a Remote

    If you want to see more information about a particular remote, you can use the

        git remote show [remote-name] 

    command.

- Tagging

    Like most VCSs, Git has the ability to tag specific points in history as being im-
    portant. Typically people use this functionality to mark release points (v1.0, and
    so on).

    - git tag
      git tag <tag_name>
      git tag -a <tag_name> <commit_checksum>  (tag a commit after the fact)
      git tag -a <tag_name> -m "tag message"
      git show <tag_name>

    - Creating Tags

        Git uses two main types of tags: lightweight and annotated.

        A lightweight tag is very much like a branch that doesn’t change – it’s just a
        pointer to a specific commit.

            git tag <tag_name>

        Annotated tags, however, are stored as full objects in the Git database.
        They’re checksummed; contain the tagger name, email, and date; have a tag-
        ging message; and can be signed and verified with GNU Privacy Guard (GPG).
        It’s generally recommended that you create annotated tags so you can have all
        this information; but if you want a temporary tag or for some reason don’t want
        to keep the other information, lightweight tags are available too.

            git tag -a <tag_name> -m "tag message"

    - Sharing Tags

        By default, the git push command doesn’t transfer tags to remote servers.
        You will have to explicitly push tags to a shared server after you have created
        them. This process is just like sharing remote branches – you can run

            git push origin [tag_name]

        If you have a lot of tags that you want to push up at once, you can also use
        the --tags option to the git push command. This will transfer all of your tags
        to the remote server that are not already there.

            git push origin --tags

    - Checking out Tags

        You can’t really check out a tag in Git, since they can’t be moved around. If you
        want to put a version of your repository in your working directory that looks
        like a specific tag, you can create a new branch at a specific tag with 

            git checkout -b [branchname] [tagname]

- Git Aliases

    one little tip that can make your Git experience simpler, easier, and more familiar: aliases. 

    Git doesn’t automatically infer your command if you type it in partially. If
    you don’t want to type the entire text of each of the Git commands, you can
    easily set up an alias for each command using git config

        git config --global alias.co checkout
        git config --global alias.br branch
        git config --global alias.ci commit
        git config --global alias.st status

        git config --global alias.last 'log -1 HEAD'    (git last; see last commit easily)

- Branching

    Note: git clone gets full copy of everything; git branch doesn't, just generates a new pointer

    Branching means you diverge from the main line of development and continue to do work without
    messing with that main line.

    The way Git branches is incredibly lightweight, making branching operations nearly instan-
    taneous, and switching back and forth between branches generally just as fast.

    Git encourages workflows that branch and merge
    often, even multiple times in a day.

    Git doesn’t store data as a series of
    changesets or differences, but instead as a series of snapshots.

    When you make a commit, Git stores a commit object that contains a pointer
    to the snapshot of the content you staged. This object also contains the au-
    thor’s name and email, the message that you typed, and pointers to the commit
    or commits that directly came before this commit (its parent or parents): zero
    parents for the initial commit, one parent for a normal commit, and multiple
    parents for a commit that results from a merge of two or more branches.

    A branch in Git is simply a lightweight movable pointer to a commit.

    The default branch name in Git is master . As you start making commits,
    you’re given a master branch that points to the last commit you made.

    The “master” branch in Git is not a special branch. It is exactly like any
    other branch. The only reason nearly every repository has one is that the
    git init command creates it by default and most people don’t bother to
    change it.

    - Creating a New Branch

        What happens if you create a new branch? Well, doing so creates a new pointer
        for you to move around. Let’s say you create a new branch called testing. You
        do this with the git branch command:

            git branch testing

        This creates a new pointer to the same commit you’re currently on.

        How does Git know what branch you’re currently on? It keeps a special
        pointer called HEAD . Note that this is a lot different than the concept of HEAD in
        other VCSs you may be used to, such as Subversion or CVS. In Git, this is a point-
        er to the local branch you’re currently on. In this case, you’re still on master .
        The git branch command only created a new branch – it didn’t switch to that
        branch.

    - Switching Branches

        To switch to an existing branch, you run the git checkout command. Let’s
        switch to the new testing branch:

            git checkout testing

        This moves HEAD to point to the testing branch.

        SWITCHING BRANCHES CHANGES FILES IN YOUR WORKING DIRECTORY

            It’s important to note that when you switch branches in Git, files in your
            working directory will change. If you switch to an older branch, your
            working directory will be reverted to look like it did the last time you
            committed on that branch. If Git cannot do it cleanly, it will not let you
            switch at all.

    Because a branch in Git is in actuality a simple file that contains the 40 char-
    acter SHA-1 checksum of the commit it points to, branches are cheap to create
    and destroy. Creating a new branch is as quick and simple as writing 41 bytes to
    a file (40 characters and a newline).

    This is in sharp contrast to the way most older VCS tools branch, which in-
    volves copying all of the project’s files into a second directory. This can take
    several seconds or even minutes, depending on the size of the project, whereas
    in Git the process is always instantaneous. Also, because we’re recording the
    parents when we commit, finding a proper merge base for merging is automati-
    cally done for us and is generally very easy to do. These features help encour-
    age developers to create and use branches often.

    When you switch branches, Git resets your
    working directory to look like it did the last time you committed on that branch.
    It adds, removes, and modifies files automatically to make sure your working
    copy is what the branch looked like on your last commit to it.

- Tracking Branches

    Checking out a local branch from a remote-tracking branch automatically cre-
    ates what is called a “tracking branch” (or sometimes an “upstream branch”).

    Tracking branches are local branches that have a direct relationship to a re-
    mote branch. If you’re on a tracking branch and type 

        git pull

    Git automatically knows which server to fetch from and branch to merge into.

    When you clone a repository, it generally automatically creates a master
    branch that tracks origin/master . However, you can set up other tracking
    branches if you wish – ones that track branches on other remotes, or don’t
    track the master branch. The simple case is the example:

        git checkout -b [branch] [remotename]/[branch]

    This is a common enough operation that git provides the --track shorthand:

        git checkout --track origin/branch_name

    In fact, this is so common that there’s even a shortcut for that shortcut. If the
    branch name you’re trying to checkout (a) doesn’t exist and (b) exactly matches
    a name on only one remote, Git will create a tracking branch for you:

        git checkout branch_name

    To set up a local branch with a different name than the remote branch, you
    can easily use the first version with a different local branch name:

        git checkout -b bn origin/branch_name

    Now, your local branch bn will automatically pull from origin/branch_name .

    If you already have a local branch and want to set it to a remote branch you
    just pulled down, or want to change the upstream branch you’re tracking, you
    can use the -u or --set-upstream-to option to git branch to explicitly set
    it at any time.

        git branch -u origin/branch_name

- git fetch vs git pull

    In the simplest terms, git pull does a git fetch followed by a git merge.

    You can do a git fetch at any time to update your remote-tracking branches under refs/remotes/<remote>/.

    This operation never changes any of your own local branches under refs/heads, and is safe to do without
    changing your working copy.

    I have even heard of people running git fetch periodically in a cron job in the background
    (although I wouldn’t recommend doing this).

    A git pull is what you would do to bring a local branch up-to-date with its remote version, 
    while also updating your other remote-tracking branches.

- Merging

    git merge <branch_name>     (merges branch_name into current branch)

    - Preparing to merge

        Before performing a merge there are a couple of preparation steps to take to ensure
        the merge goes smoothly.

        - Confirm the receiving branch

        - Execute git status to ensure that HEAD is pointing to the correct merge-receiving branch. 
          If needed, execute 

                git checkout <receiving> 

          to switch to the receiving branch.

        - Fetch latest remote commits

            - Make sure the receiving branch and the merging branch are up-to-date with the latest remote changes.
              
                - Checkout the merging branch (usually the local repository: git checkout <merging branch>)
                - Execute "git fetch" to pull the latest remote commits for the "merging branch". 
                - Checkout the receiving branch (git checkout <receiving_branch>)
                - Ensure the receiving branch has the latest updates by executing "git pull".

    - Merging

        Once the previously discussed "preparing to merge" steps have been taken a merge can be initiated by
        executing git merge <branch name> where <branch name> is the name of the branch that will be merged
        into the receiving branch.

    - How conflicts are presented

        Use git status for more info

        NOTE: only have to change the conflicting file in the receiving branch

        When Git encounters a conflict during a merge, It will edit the content of the affected files with
        visual indicators that mark both sides of the conflicted content. These visual markers are: <<<<<<<,
        =======, and >>>>>>>. Its helpful to search a project for these indicators during a merge to find
        where conflicts need to be resolved.

        Generally the content before the ======= marker is the receiving branch and the part after is the
        merging branch.

        Once you've identified conflicting sections, you can go in and fix up the merge to your liking. 
        When you're ready to finish the merge, all you have to do is run git add on the conflicted file(s)
        to tell Git they're resolved. Then, you run a normal git commit to generate the merge commit. It’s
        the exact same process as committing an ordinary snapshot, which means it’s easy for normal developers
        to manage their own merges.

        Should you decide not to use a merge tool and instead clean up the file in your editor, you'll have
        to mark the file as resolved by hand (by executing "git add <filename>").
        Finally, after solving all conflicts, a merge conflict situation needs to be concluded by a regular 
        commit.

- Rebasing

    git rebase <branch_name>

    Another way, beside merge, to integrate changes from one branch into another

    With the rebase command, you can take all the changes that were committed
    on one branch and replay them on another one.

    It works by going to the common ancestor of the two branches (the one
    you’re on and the one you’re rebasing onto), getting the diff introduced by each
    commit of the branch you’re on, saving those diffs to temporary files, resetting
    the current branch to the same commit as the branch you are rebasing onto,
    and finally applying each change in turn.

    Rebasing makes for a cleaner history. If you examine
    the log of a rebased branch, it looks like a linear history: it appears that all the
    work happened in series, even when it originally happened in parallel.

    Often, you’ll do this to make sure your commits apply cleanly on a remote
    branch – perhaps in a project to which you’re trying to contribute but that you
    don’t maintain. In this case, you’d do your work in a branch and then rebase
    your work onto origin/master when you were ready to submit your patches
    to the main project. That way, the maintainer doesn’t have to do any integra-
    tion work – just a fast-forward or a clean apply.

    Note that the snapshot pointed to by the final commit you end up with,
    whether it’s the last of the rebased commits for a rebase or the final merge
    commit after a merge, is the same snapshot – it’s only the history that is differ-
    ent. Rebasing replays changes from one line of work onto another in the order
    they were introduced, whereas merging takes the endpoints and merges them
    together.

    - Perils of Rebasing

        Ahh, but the bliss of rebasing isn’t without its drawbacks, which can be sum-
        med up in a single line:

            Do not rebase commits that exist outside your repository.

        When you rebase stuff, you’re abandoning existing commits and creating
        new ones that are similar but different. If you push commits somewhere and
        others pull them down and base work on them, and then you rewrite those
        commits with git rebase and push them up again, your collaborators will
        have to re-merge their work and things will get messy when you try to pull their
        work back into yours.

        If you treat rebasing as a way to clean up and work with commits before you
        push them, and if you only rebase commits that have never been available pub-
        licly, then you’ll be fine. If you rebase commits that have already been pushed
        publicly, and people may have based work on those commits, then you may be
        in for some frustrating trouble, and the scorn of your teammates.

        If you or a partner does find it necessary at some point, make sure everyone
        knows to run git pull --rebase to try to make the pain after it happens a
        little bit simpler.

        In general the way to get the best of both worlds is to rebase local changes
        you’ve made but haven’t shared yet before you push them in order to clean up
        your story, but never rebase anything you’ve pushed somewhere.

GitHub
------

- The way that GitHub maps your Git commits to your user is by email address.

- Forking Projects

    If you want to contribute to an existing project to which you don’t have push
    access, you can “fork” the project. What this means is that GitHub will make a
    copy of the project that is entirely yours; it lives in your user’s namespace, and
    you can push to it.

    This way, projects don’t have to worry about adding users as collaborators
    to give them push access. People can fork a project, push to it, and contribute
    their changes back to the original repository by creating what’s called a 
    Pull Request,

    Historically, the term “fork” has been somewhat negative in context,
    meaning that someone took an open source project in a different direc-
    tion, sometimes creating a competing project and splitting the contribu-
    tors. In GitHub, a “fork” is simply the same project in your own name-
    space, allowing you to make changes to a project publicly as a way to
    contribute in a more open manner.




Modified: 05/01/19


Git Cheatsheet
==============


- Git is a DVCS

    Distributed Version Control System


- The major difference between Git and any other VCS (Subversion and friends
  included) is the way Git thinks about its data. Conceptually, most other systems
  store information as a list of file-based changes. These systems (CVS, Subver-
  sion, Perforce, Bazaar, and so on) think of the information they keep as a set of
  files and the changes made to each file over time.

  Git doesn’t think of or store its data this way. Instead, Git thinks of its data
  more like a set of snapshots of a miniature filesystem. Every time you commit,
  or save the state of your project in Git, it basically takes a picture of what all
  your files look like at that moment and stores a reference to that snapshot. To
  be efficient, if files have not changed, Git doesn’t store the file again, just a link
  to the previous identical file it has already stored. Git thinks about its data more
  like a stream of snapshots.

  This makes Git more like a mini
  filesystem with some incredibly powerful tools built on top of it, rather than
  simply a VCS.

- Nearly Every Operation Is Local
  
  Most operations in Git only need local files and resources to operate – generally
  no information is needed from another computer on your network.

  This also means that there is very little you can’t do if you’re offline or off
  VPN.

- The Three States

  Git has three main states that
  your files can reside in: 

        committed, 
        modified, and 
        staged.

  Committed means
  that the data is safely stored in your local database. 

  Modified means 
  that you have changed the file but have not committed it to your database yet. 

  Staged means that you have marked a modified file in its current version to go into
  your next commit snapshot.

  This leads us to the three main sections of a Git project: 

       the Git directory, 
       the working directory, and 
       the staging area.

  The Git directory is where Git stores the metadata and object database for
  your project. This is the most important part of Git, and it is what is copied
  when you clone a repository from another computer.

  The working directory is a single checkout of one version of the project.
  These files are pulled out of the compressed database in the Git directory and
  placed on disk for you to use or modify.

  The staging area is a file, generally contained in your Git directory, that
  stores information about what will go into your next commit. It’s sometimes re-
  ferred to as the “index”, but it’s also common to refer to it as the staging area.

  The basic Git workflow goes something like this:

    1. You modify files in your working directory.
    2. You stage the files, adding snapshots of them to your staging area.
    3. You do a commit, which takes the files as they are in the staging area and
       stores that snapshot permanently to your Git directory.
    
    If a particular version of a file is in the Git directory, it’s considered committed. 
    If it has been modified and was added to the staging area, it is staged. And
    If it was changed since it was checked out but has not been staged, it is modified.

    Working Directory                   Staging Area                .git directdory (Repository)
    -----------------                   ------------                ----------------------------
          |                                   |                                    | 
          |<======================== Checkout the project =======================> |
          |                                   |                                    |
          | Stage Fixes ===================>  |                                    |
          |                                   |                                    |
          |                                   | Commit ==========================> |

- configuration

    - config files

        1. /etc/gitconfig file: Contains values for every user on the system and
                                all their repositories. 

                                If you pass the option --system to git config , it
                                reads and writes from this file specifically.

        2. ~/.gitconfig or ~/.config/git/config file: 

                                Specific to your user.

                                You can make Git read and write to this file specifically by passing the 
                                --global option.

        3. config file in the Git directory (that is, .git/config ) of whatever repos-
           itory you’re currently using: 

                                Specific to that single repository.

        Each level overrides values in the previous level, so values in .git/config
        trump those in /etc/gitconfig.


    - setting settings

        git config --global user.name "John Doe"
        git config --global user.email johndoe@example.com
        git config --global core.editor emacs

        Again, you need to do this only once if you pass the --global option, be-
        cause then Git will always use that information for anything you do on that sys-
        tem. If you want to override this with a different name or email address for spe-
        cific projects, you can run the command without the --global option when
        you’re in that project.

    - listing settings

        - git config --list

        You may see keys more than once, because Git reads the same key from dif-
        ferent files ( /etc/gitconfig and ~/.gitconfig , for example). In this case,
        Git uses the last value for each unique key it sees.

    You can also check what Git thinks a specific key’s value is by typing

        git config <key> :

        example:

            git config user.name
            John Doe

- Getting a Git Repository

  You can get a Git project using two main approaches. 

     The first takes an existing project or directory and imports it into Git. 
     The second clones an existing Git repository from another server.

  - Initializing a Repository in an Existing Directory

    If you’re starting to track an existing project in Git, you need to go to the
    project’s directory and type:

        git init

    This creates a new subdirectory named .git that contains all of your neces-
    sary repository files – a Git repository skeleton. At this point, nothing in your
    project is tracked yet

    If you want to start version-controlling existing files (as opposed to an empty
    directory), you should probably begin tracking those files and do an initial com-
    mit. You can accomplish that with a few git add commands that specify the
    files you want to track, followed by a git commit :

        git add *.c
        git add LICENSE
        git commit -m 'initial project version'

    At this point, you have a Git repository with tracked files and an initial commit.

- Cloning an Existing Repository

    If you want to get a copy of an existing Git repository – for example, a project
    you’d like to contribute to – the command you need is git clone . 

    If you’re fa-
    miliar with other VCS systems such as Subversion, you’ll notice that the com-
    mand is “clone” and not “checkout”. This is an important distinction – instead
    of getting just a working copy, Git receives a full copy of nearly all data that the
    server has. Every version of every file for the history of the project is pulled
    down by default when you run git clone .

    You clone a repository with git clone [url] . For example, if you want to
    clone the Git linkable library called libgit2, you can do so like this:

        git clone https://github.com/libgit2/libgit2

    That creates a directory named “libgit2”, initializes a .git directory inside it,
    pulls down all the data for that repository, and checks out a working copy of the
    latest version.

    If you want to clone the repository
    into a directory named something other than “libgit2”, you can specify that as
    the next command-line option:

        git clone https://github.com/libgit2/libgit2 mylibgit

    That command does the same thing as the previous one, but the target di-
    rectory is called mylibgit.

- Checking the Status of Your Files

    The main tool you use to determine which files are in which state is the git
    status command. If you run this command directly after a clone, you should
    see something like this:

        git status
        On branch master
        nothing to commit, working directory clean

        This means you have a clean working directory – in other words, there are no
        tracked and modified files. Git also doesn’t see any untracked files, or they
        would be listed here. Finally, the command tells you which branch you’re on
        and informs you that it has not diverged from the same branch on the server.
        For now, that branch is always “master”, which is the default

- git add

    git add is a multipurpose command – you use it to begin tracking
    new files, to stage files, and to do other things like marking merge-conflicted
    files as resolved. It may be helpful to think of it more as “add this content to the
    next commit” rather than “add this file to the project”

    Git stages a file exactly as it is when you run the git add command.

    If you modify a file after you run git add , you have
    to run git add again to stage the latest version of the file.

- Committing Your Changes

    Now that your staging area is set up the way you want it, you can commit your
    changes. Remember that anything that is still unstaged – any files you have cre-
    ated or modified that you haven’t run git add on since you edited them –
    won’t go into this commit. They will stay as modified files on your disk.

    Remember that the commit records the snapshot you set up in your staging
    area. Anything you didn’t stage is still sitting there modified; you can do anoth-
    er commit to add it to your history. Every time you perform a commit, you’re
    recording a snapshot of your project that you can revert to or compare to later.

    Skipping the Staging Area

        Although it can be amazingly useful for crafting commits exactly how you want
        them, the staging area is sometimes a bit more complex than you need in your
        workflow. If you want to skip the staging area, Git provides a simple shortcut.
        Adding the -a option to the git commit command makes Git automatically
        stage every file that is already tracked before doing the commit, letting you skip
        the git add part.

- Removing files

        git rm <filename>

    To remove a file from Git, you have to remove it from your tracked files (more
    accurately, remove it from your staging area) and then commit. The git rm
    command does that, and also removes the file from your working directory so
    you don’t see it as an untracked file the next time around.       

    If you simply remove the file from your working directory, it shows up under
    the “Changed but not updated” (that is, unstaged) area of your git status
    output.

        $ rm PROJECTS.md
        $ git status
        Then, if you run git rm , it stages the file’s removal:
        $ git rm PROJECTS.md
        $ git status

        The next time you commit, the file will be gone and no longer tracked. If you
        modified the file and added it to the index already, you must force the removal
        with the -f option. This is a safety feature to prevent accidental removal of data
        that hasn’t yet been recorded in a snapshot and that can’t be recovered from
        Git.

    NOTE: can also do

        rm <filename>
        git add -A .

    Another useful thing you may want to do is to keep the file in your working
    tree but remove it from your staging area. In other words, you may want to
    keep the file on your hard drive but not have Git track it anymore. This is partic-
    ularly useful if you forgot to add something to your .gitignore file and acci-
    dentally staged it, like a large log file or a bunch of .a compiled files. To do this,
    use the --cached option:

        git rm --cached README

    You can pass files, directories, and file-glob patterns to the git rm command.

- Moving Files

    Unlike many other VCS systems, Git doesn’t explicitly track file movement. If
    you rename a file in Git, no metadata is stored in Git that tells it you renamed
    the file. However, Git is pretty smart about figuring that out after the fact – we’ll
    deal with detecting file movement a bit later.

    Thus it’s a bit confusing that Git has a mv command. If you want to rename a
    file in Git, you can run something like:

        git mv file_from file_to

    this is equivalent to running something like this:

    mv README.md README
    git rm README.md
    git add README

    Git figures out that it’s a rename implicitly, so it doesn’t matter if you re-
    name a file that way or with the mv command. The only real difference is that
    mv is one command instead of three – it’s a convenience function.

- Viewing the Commit History

    After you have created several commits, or if you have cloned a repository with
    an existing commit history, you’ll probably want to look back to see what has
    happened. The most basic and powerful tool to do this is

        git log

- Undoing Things

    At any stage, you may want to undo something. Here, we’ll review a few basic
    tools for undoing changes that you’ve made. Be careful, because you can’t al-
    ways undo some of these undos. This is one of the few areas in Git where you
    may lose some work if you do it wrong.

    One of the common undos takes place when you commit too early and pos-
    sibly forget to add some files, or you mess up your commit message. If you want
    to try that commit again, you can run commit with the --amend option:

        git commit --amend

    This command takes your staging area and uses it for the commit. If you’ve
    made no changes since your last commit (for instance, you run this command
    immediately after your previous commit), then your snapshot will look exactly
    the same, and all you’ll change is your commit message.

    The same commit-message editor fires up, but it already contains the mes-
    sage of your previous commit. You can edit the message the same as always,
    but it overwrites your previous commit.

    As an example, if you commit and then realize you forgot to stage the
    changes in a file you wanted to add to this commit, you can do something like
    this:

        git commit -m 'initial commit'
        git add forgotten_file
        git commit --amend

    You end up with a single commit – the second commit replaces the results of
    the first.

- Showing your remotes

    git remote
    git remote -v

- Fetching and Pulling from Your Remotes

    As you just saw, to get data from your remote projects, you can run:

        git fetch [remote-name]

    The command goes out to that remote project and pulls down all the data
    from that remote project that you don’t have yet. After you do this, you should
    have references to all the branches from that remote, which you can merge in
    or inspect at any time.

    If you clone a repository, the command automatically adds that remote
    repository under the name “origin”. So, git fetch origin fetches any new
    work that has been pushed to that server since you cloned (or last fetched
    from) it. It’s important to note that the git fetch command pulls the data to
    your local repository – it doesn’t automatically merge it with any of your work
    or modify what you’re currently working on. You have to merge it manually into
    your work when you’re ready.

    If you have a branch set up to track a remote branch, you can use the git pull command to
    automatically fetch and then merge a remote branch into your current branch.
    This may be an easier or more comfortable workflow for you; and by default,
    the git clone command automatically sets up your local master branch to
    track the remote master branch (or whatever the default branch is called) on
    the server you cloned from. Running git pull generally fetches data from the
    server you originally cloned from and automatically tries to merge it into the
    code you’re currently working on.

- Pushing to Your Remotes

    When you have your project at a point that you want to share, you have to push
    it upstream. The command for this is simple: 

        git push [remote-name] [branch-name] 

    If you want to push your master branch to your origin server
    (again, cloning generally sets up both of those names for you automatically),
    then you can run this to push any commits you’ve done back up to the server:

        git push origin master

    This command works only if you cloned from a server to which you have
    write access and if nobody has pushed in the meantime. If you and someone
    else clone at the same time and they push upstream and then you push up-
    stream, your push will rightly be rejected. You’ll have to pull down their work
    first and incorporate it into yours before you’ll be allowed to push.

- Inspecting a Remote

    If you want to see more information about a particular remote, you can use the

        git remote show [remote-name] 

    command.

- Branching

    Branching means you diverge from the main line of development and continue to do work without
    messing with that main line.

    Git doesn’t store data as a series of
    changesets or differences, but instead as a series of snapshots.

    When you make a commit, Git stores a commit object that contains a pointer
    to the snapshot of the content you staged. This object also contains the au-
    thor’s name and email, the message that you typed, and pointers to the commit
    or commits that directly came before this commit (its parent or parents): zero
    parents for the initial commit, one parent for a normal commit, and multiple
    parents for a commit that results from a merge of two or more branches.

    The default branch name in Git is master . As you start making commits,
    you’re given a master branch that points to the last commit you made.

    The “master” branch in Git is not a special branch. It is exactly like any
    other branch. The only reason nearly every repository has one is that the
    git init command creates it by default and most people don’t bother to
    change it.

    - Creating a New Branch

        What happens if you create a new branch? Well, doing so creates a new pointer
        for you to move around. Let’s say you create a new branch called testing. You
        do this with the git branch command:

            git branch testing

        This creates a new pointer to the same commit you’re currently on.

        How does Git know what branch you’re currently on? It keeps a special
        pointer called HEAD . Note that this is a lot different than the concept of HEAD in
        other VCSs you may be used to, such as Subversion or CVS. In Git, this is a point-
        er to the local branch you’re currently on. In this case, you’re still on master .
        The git branch command only created a new branch – it didn’t switch to that
        branch.

    - Switching Branches

        To switch to an existing branch, you run the git checkout command. Let’s
        switch to the new testing branch:

            git checkout testing

        This moves HEAD to point to the testing branch.

        SWITCHING BRANCHES CHANGES FILES IN YOUR WORKING DIRECTORY

            It’s important to note that when you switch branches in Git, files in your
            working directory will change. If you switch to an older branch, your
            working directory will be reverted to look like it did the last time you
            committed on that branch. If Git cannot do it cleanly, it will not let you
            switch at all.

    Because a branch in Git is in actuality a simple file that contains the 40 char-
    acter SHA-1 checksum of the commit it points to, branches are cheap to create
    and destroy. Creating a new branch is as quick and simple as writing 41 bytes to
    a file (40 characters and a newline).

    This is in sharp contrast to the way most older VCS tools branch, which in-
    volves copying all of the project’s files into a second directory. This can take
    several seconds or even minutes, depending on the size of the project, whereas
    in Git the process is always instantaneous. Also, because we’re recording the
    parents when we commit, finding a proper merge base for merging is automati-
    cally done for us and is generally very easy to do. These features help encour-
    age developers to create and use branches often.

    When you switch branches, Git resets your
    working directory to look like it did the last time you committed on that branch.
    It adds, removes, and modifies files automatically to make sure your working
    copy is what the branch looked like on your last commit to it.



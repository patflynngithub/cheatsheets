Updated: April 13, 2019

- go over

    - xargs
    - getopts

Bash CheatSheet
===============

- Internal Commands and Builtins

    A builtin is a command contained within the Bash tool set, literally built in. This is either for performance
    reasons -- builtins execute faster than external commands, which usually require forking off a separate
    process -- or because a particular builtin needs direct access to the shell internals.  

    Generally, a Bash builtin does not fork a subprocess when it executes within a script. An external system
    command or filter in a script usually will fork a subprocess.
    
    A builtin may be a synonym to a system command of the same name, but Bash reimplements it internally. For
    example, the Bash echo command is not the same as /bin/echo, although their behavior is almost
    identical.

    A keyword is a reserved word, token or operator. Keywords have a special meaning to the shell, and indeed
    are the building blocks of the shell's syntax. As examples, for, while, do, and ! are keywords. Similar to a
    builtin, a keyword is hard-coded into Bash, but unlike a builtin, a keyword is not in itself a command, but a
    subunit of a command construct.

    In general, an external command in a script forks off a subprocess, whereas a Bash builtin does not. For
    this reason, builtins execute more quickly and use fewer system resources than their external command
    equivalents.

- Bash does not understand floating point arithmetic. It treats numbers containing a decimal point as
  strings.

- Running a shell script launches a new process, a subshell.

    Definition: A subshell is a child process launched by a shell (or shell script).

    A subshell is a separate instance of the command processor -- the shell that gives you the prompt at the
    console or in an xterm window. Just as your commands are interpreted at the command-line prompt, similarly
    does a script batch-process a list of commands. Each shell script running is, in effect, a subprocess (child
    process) of the parent shell.

    ( command1; command2; command3; ... )

        A command list embedded between parentheses runs as a subshell.

- put variables in parentheses when comparing them or "operating" them

    e.g.,   if [ "$UID" -ne "$ROOT_UID" ]
            if [ -n "$1" ]
            if [ `pwd` != "$LOG_DIR" ]  # or if [ "$PWD" != "$LOG_DIR" ]

- variables

    - Let us carefully distinguish between the name of a variable and its value. If variable1 is the name
      of a variable, then $variable1 is a reference to its value, the data item it contains.

    - The only times a variable appears "naked" -- without the $ prefix -- is when declared or assigned,
      when unset, when exported, in an arithmetic expression within double parentheses (( ... )), or in the
      special case of a variable representing a signal

    - Referencing (retrieving) variable values is called variable substitution.

        echo $hello
        echo ${hello}

    - Enclosing a referenced value in double quotes (" ... ") does not interfere with variable substitution.
      This is called partial quoting, sometimes referred to as "weak quoting." Using single quotes (' ... ')
      causes the variable name to be used literally, and no substitution will take place. This is full quoting,
      sometimes referred to as 'strong quoting.'

    - quoting a variable preserves whitespace.

    - Note that $variable is actually a simplified form of ${variable}. In contexts where the
      $variable syntax causes an error, the longer form may work

    - $hello=            # sets to null value

    - If there is whitespace embedded within a variable,
      then quotes are necessary.

    - Bash Variables Are Untyped

      Unlike many other programming languages, Bash does not segregate its variables by "type." Essentially, Bash
      variables are character strings, but, depending on context, Bash permits arithmetic operations and
      comparisons on variables. The determining factor is whether the value of a variable contains only digits.

      Bash does "permit" declaring variables.

- examples in script file

    - note: sha-bang #! on first line/column
    
        - #! can be omitted if the script consists only of a set of generic system commands, using no internal shell
          directives.

        #!/bin/bash

        # Comment

        echo "username is $HELLO"    # comment

        COLOUR="BLACK"
        VALUE="9"

- comment

    # example

- command separator:    ;

     echo hello; echo there

     if [ -x "$filename" ]; then   # Note the space after the semicolon.

- command substitution

    Command substitution reassigns the output of a command [55] or even multiple commands; it literally plugs
    the command output into another context. [56]

    - $(...) form

        The $(...) form has superseded backticks for command substitution.

            output=$(sed -n /"$1"/p $file)

            # Setting a variable to the contents of a text file.
            File_contents1=$(cat $file1)
            File_contents2=$(<$file2)       # Bash permits this also.

        The $(...) form of command substitution treats a double backslash in a different way than `...`.

        The $(...) form of command substitution permits nesting.

            word_count=$( wc -w $(echo * | awk '{print $8}') )
    - backticks

        The classic form of command substitution uses backquotes (`...`). Commands within backquotes (backticks)
        generate command-line text.

        ` ... `

        The `command` construct makes available the output of command for
        assignment to a variable. This is also known as backquotes or backticks.

            script_name=`basename $0`
            echo "The name of this script is $script_name."

        The output of commands can be used as arguments to another command, to set a variable, and even for
        generating the argument list in a for loop.

        "arg list too long" error might result.
        # Better is   xargs rm -- < filename
        # ( -- covers those cases where "filename" begins with a "-" )

        # The alternative form of command substitution.
        textfile_listing2=$(ls *.txt)
        echo $textfile_listing2

        Command substitution invokes a subshell.

        Command substitution may result in word splitting.

        Even when there is no word splitting, command substitution can remove trailing newlines.

        Using echo to output an unquoted variable set with command substitution removes trailing newlines
        characters from the output of the reassigned command(s). This can cause unpleasant surprises.

        Command substitution even permits setting a variable to the contents of a file, using either redirection or the
            cat command.
            variable1=`<file1`      #  Set "variable1" to contents of "file1".
            variable2=`cat file2`   #  Set "variable2" to contents of "file2".
                                    #  This, however, forks a new process,
                                    #+ so the line of code executes slower than the above version.
            # Note that the variables may contain embedded whitespace,
            #+ or even (horrors), control characters.

        - e.g., say have compiled Hello World C program

                #!/bin/bash
                # hello.sh
                greeting=`./hello`

- null command [colon]

    :

    This is the shell equivalent of a "NOP" (no op, a do-nothing operation). It
    may be considered a synonym for the shell builtin true. The ":" command is itself a Bash builtin, and
    its exit status is true (0).

    Can be used as placeholder

- $[ ... ]

    integer expansion.

    Evaluate integer expression between $[ ]

        a=3
        b=7
        echo $[$a+$b]
        echo $[$a*$b]
        # 10
        # 21

    Note that this usage is deprecated, and has been replaced by the (( ... )) construct.
- (( ))

    integer expansion.

    Expand and evaluate integer expression between (( )).

- running Bash script files

        chmod u+x script1.sh
        script1.sh

    - If you did not put the scripts directory in your PATH, and . (the current directory) is not in the PATH
      either, you can activate the script like this:

        ./script_name.sh

    - if you don't want to start a new shell but execute the script in the current shell, you source it:

        source script_name.sh   (source = .)

      The Bash source built-in is a synonym for the Bourne shell . (dot) command.

      The script does not need execute permission in this case. Commands are executed in the current shell context,
      so any changes made to your environment will be visible when the script finishes execution:

- debug in Bash scripts




    bash -x script1.sh

    set -x   # activate debugging from here
    w
    set +x   # stop debugging from here

    Short notation  Long notation     Result
    --------------  -------------     ------
    set -f          set -o noglob     Disable file name generation using metacharacters (globbing)
    set -v          set -o verbose    Prints shell input lines as they are read.
    set -x          set -o xtrace     Print command traces before executing command.
    set -n          set -o noexec     check for syntax errors w/o actually running the script

    - The dash is used to activate a shell option and a plus to deactivate it. Don't let this confuse you!

    - Alternatively, these modes can be specified in the script itself, by adding the desired options to the first line
      shell declaration. Options can be combined, as is usually the case with UNIX commands:

            #!/bin/bash -xv

- e.g. if change .bashrc, do "source .bashrc"

- shell variables

    - When referencing a variable, it is generally advisable to enclose its name in double quotes. This prevents
      reinterpretation of all special characters within the quoted string -- except $, ` (backquote), and \ (escape). [30]
      Keeping $ as a special character within double quotes permits referencing a quoted variable
      ("$variable"), that is, replacing the variable with its value.

    - shell variables are in uppercase characters by convention

    - env or printenv to display

    - Global variables or environment variables are available in all shells.
 
           - VARNAME="value"
             export VARNAME

             or
            
             export VARNAME="value"

    - Local variables are only available in the current shell

    - To set a variable in the shell, use

         VARNAME="value"    (no spaces around =)

      Putting spaces around the equal sign will cause errors. It is a good habit to quote content strings when
      assigning values to variables: this will reduce the chance that you make errors.

      Note that = can be either an assignment or a test operator, depending on context.

    - env or printenv to display environment variables
    - set prints local AND environment variables

    - types of variable contents

        • String variables
        • Integer variables
        • Constant variables
        • Array variables

    - Variables are case sensitive and capitalized by default. Giving local variables a lowercase name is a
      convention which is sometimes applied. However, you are free to use the names you want or to mix cases.
      Variables can also contain digits, but a name starting with a digit is not allowed

    - to display
         
         echo $VARNAME

    - unset VARNAME

- The shell treats several parameters specially. These parameters may only be referenced; assignment to them is
  not allowed.

        Character       Definition
        ---------       ----------
        $*              Expands to the positional parameters, starting from one. When the expansion occurs within
                        double quotes, it expands to a single word with the value of each parameter separated by the first
                        character of the IFS special variable.
        $@              Expands to the positional parameters, starting from one. When the expansion occurs within
                        double quotes, each parameter expands to a separate word.
        $#              Expands to the number of positional parameters in decimal.
        $?              Expands to the exit status of the most recently executed foreground pipeline.
        $-              A hyphen expands to the current option flags as specified upon invocation, by the set built-in
                        command, or those set by the shell itself (such as the -i).
        $$              Expands to the process ID of the shell.
        $!              Expands to the process ID of the most recently executed background (asynchronous) command.
        $0              Expands to the name of the shell or shell script.
        $_              The underscore variable is set at shell startup and contains the absolute file name of the shell or
                        script being executed as passed in the argument list. Subsequently, it expands to the last argument
                        to the previous command, after expansion. It is also set to the full pathname of each command
                        executed and placed in the environment exported to that command. When checking mail, this
                        parameter holds the name of the mail file.

    - $* vs. $@

        The implementation of "$*" has always been a problem and realistically should have been
        replaced with the behavior of "$@". In almost every case where coders use "$*", they mean
        "$@". "$*" Can cause bugs and even security holes in your software.

    - The positional parameters are the words following the name of a shell script. They are put into the variables
      $1, $2, $3 and so on

        - useful technique

              args=$#   # Number of args passed.
              lastarg=${!args}
              # Note: This is an *indirect reference* to $args ...

              or

              lastarg=${!#}


        - If a script expects a command-line parameter but is invoked without one, this may
          cause a null variable assignment, generally an undesirable result. One way to prevent
          this is to append an extra character to both sides of the assignment statement using the
          expected positional parameter.    

- escape character  \

        Escape characters are used to remove the special meaning from a single character. A non-quoted backslash, \,
        is used as an escape character in Bash. It preserves the literal value of the next character that follows, with the
        exception of newline. If a newline character appears immediately after the backslash, it marks the continuation
        of a line when it is longer that the width of the terminal; the backslash is removed from the input stream and
        effectively ignored.

- Single quotes

    Single quotes (' ') operate similarly to double quotes, but do not permit referencing variables, since the special
    meaning of $ is turned off. Within single quotes, every special character except ' gets interpreted literally.
    Consider single quotes ("full quoting") to be a stricter method of quoting than double quotes ("partial
    quoting").

    Single quotes (' ... ') are used to preserve the literal value of each character enclosed within the quotes. A single
    quote may not occur between single quotes, even when preceded by a backslash.

         echo '$date'
         $date

- quoting

    Certain programs and utilities reinterpret or expand special characters in a quoted string. An important use of
    quoting is protecting a command-line parameter from the shell, but still letting the calling program expand it.

    Quoting can also suppress echo's "appetite" for newlines.

- Double quotes

    Using double quotes the literal value of all characters enclosed is preserved, except for the dollar sign, the
    backticks (backward single quotes, ``) and the backslash.

    Use double quotes to prevent word splitting. [31] An argument enclosed in double quotes presents itself as a
    single word, even if it contains whitespace separators.

    When referencing a variable, it is generally advisable to enclose its name in double quotes. This prevents
    reinterpretation of all special characters within the quoted string -- except $, ` (backquote), and \ (escape). [30]
    Keeping $ as a special character within double quotes permits referencing a quoted variable
    ("$variable"), that is, replacing the variable with its value (see Example 4-1, above).

    The dollar sign and the backticks retain their special meaning within the double quotes.

    The backslash retains its meaning only when followed by dollar, backtick, double quote, backslash or
    newline. Within double quotes, the backslashes are removed from the input stream when followed by one of
    these characters. Backslashes preceding characters that don't have a special meaning are left unmodified for
    processing by the shell interpreter.

    A double quote may be quoted within double quotes by preceding it with a backslash.

    partial quoting [double quote]. "STRING" preserves (from interpretation) most of the special
    characters within STRING.

    full quoting [single quote]. 'STRING' preserves all special characters within STRING. This is a
    stronger form of quoting than "STRING".

- echo "`date`"
  Sun Apr 20 11:22:06 CEST 2003

- double parentheses construct

    Similar to the let command, the (( ... )) construct permits arithmetic expansion and evaluation. In its simplest
    form, a=$(( 5 + 3 )) would set a to 5 + 3, or 8. However, this double-parentheses construct is also a
    mechanism for allowing C-style manipulation of variables in Bash, for example, (( var++ )).

- shell expansion

    1) General

        - After the command has been split into tokens (see Section 1.4.1.1), these tokens or words are expanded or
          resolved. There are eight kinds of expansion performed. After all expansions, quote removal is performed.
          Below, the expansions are listed in their order of priority.

    2) brace expansion

        Brace expansion is a mechanism by which arbitrary strings may be generated. Patterns to be brace-expanded
        take the form of an optional PREAMBLE, followed by a series of comma-separated strings between a pair of
        braces, followed by an optional POSTSCRIPT. Brace expansions may be nested.

            echo sp{el,il,al}l
            spell spill spall

        Brace expansion is performed before any other expansions, and any characters special to other expansions are
        preserved in the result. It is strictly textual. Bash does not apply any syntactic interpretation to the context of
        the expansion or the text between the braces. To avoid conflicts with parameter expansion, the string "${" is
        not considered eligible for brace expansion.

        A correctly-formed brace expansion must contain unquoted opening and closing braces, and at least one
        unquoted comma. Any incorrectly formed brace expansion is left unchanged.

    3) tilde expansion

        If a word begins with an unquoted tilde character ("~"), all of the characters up to the first unquoted slash (or
        all characters, if there is no unquoted slash) are considered a tilde-prefix. If none of the characters in the
        tilde-prefix are quoted, the characters in the tilde-prefix following the tilde are treated as a possible login
        name. If this login name is the null string, the tilde is replaced with the value of the HOME shell variable. If
        HOME is unset, the home directory of the user executing the shell is substituted instead. Otherwise, the
        tilde-prefix is replaced with the home directory associated with the specified login name. 
        
        See Bash guides for more details.

    4) Shell parameter and variable expansion

        The "$" character introduces parameter expansion, command substitution, or arithmetic expansion. The
        parameter name or symbol to be expanded may be enclosed in braces, which are optional but serve to protect
        the variable to be expanded from characters immediately following it which could be interpreted as part of the
        name.

        If the first character of "PARAMETER" is an exclamation point, Bash uses the value of the variable formed
        from the rest of "PARAMETER" as the name of the variable; this variable is then expanded and that value is
        used in the rest of the substitution, rather than the value of "PARAMETER" itself. This is known as indirect
        expansion. The following is an example of indirect expansion:

            echo ${!N*}
            NNTPPORT NNTPSERVER NPX_PLUGIN_PATH

        The following construct allows for creation of the named variable if it does not yet exist:

            ${VAR:=value}

        Another examples

            height="$2"
            idealweight=$[$height - 110]

    5) Command substitution

        Command substitution allows the output of a command to replace the command itself. Command substitution
        occurs when a command is enclosed like this:

            $(command)

        or like this using backticks:

            `command`

        Bash performs the expansion by executing COMMAND and replacing the command substitution with the
        standard output of the command, with any trailing newlines deleted. Embedded newlines are not deleted, but
        they may be removed during word splitting.

            echo `date`
            Thu Feb 6 10:06:20 CET 2003
        
        When the old-style backquoted form of substitution is used, backslash retains its literal meaning except when
        followed by "$", "`", or "\". The first backticks not preceded by a backslash terminates the command
        substitution. When using the "$(COMMAND)" form, all characters between the parentheses make up the
        command; none are treated specially.
        Command substitutions may be nested. To nest when using the backquoted form, escape the inner backticks
        with backslashes.

        If the substitution appears within double quotes, word splitting and file name expansion are not performed on
        the results.

    6) Arithmetic expansion

        Arithmetic expansion allows the evaluation of an arithmetic expression and the substitution of the result. The
        format for arithmetic expansion is:

            $(( EXPRESSION ))

        The expression is treated as if it were within double quotes, but a double quote inside the parentheses is not
        treated specially. All tokens in the expression undergo parameter expansion, command substitution, and quote
        removal. Arithmetic substitutions may be nested.
        
        Evaluation of arithmetic expressions is done in fixed-width integers with no check for overflow - although
        division by zero is trapped and recognized as an error. The operators are roughly the same as in the C
        programming language.

        In order of decreasing precedence, the list looks like this:

            Operator                Meaning
            --------                -------
            VAR++ and VAR--         variable post-increment and post-decrement
            ++VAR and --VAR         variable pre-increment and pre-decrement
            - and +                 unary minus and plus
            ! and ~                 logical and bitwise negation
            **                      exponentiation
            *, / and %              multiplication, division, remainder
            + and -                 addition, subtraction
            << and >>               left and right bitwise shifts
            <=, >=, < and >         comparison operators
            == and !=               equality and inequality
            &                       bitwise AND
            ^                       bitwise exclusive OR
            |                       bitwise OR
            &&                      logical AND   (not permitted inside single bracket construct [ ... ])
            ||                      logical OR    (not permitted inside single bracket construct [ ... ])
            expr ? expr : expr      conditional evaluation
            =, *=, /=, %=, +=,
             -=, <<=, >>=, &=, 
            ^= and |=               assignments
            ,                       separator between expressions

        Shell variables are allowed as operands; parameter expansion is performed before the expression is evaluated.
        Within an expression, shell variables may also be referenced by name without using the parameter expansion
        syntax. The value of a variable is evaluated as an arithmetic expression when it is referenced. A shell variable
        need not have its integer attribute turned on to be used in an expression.

        Wherever possible, Bash users should try to use the syntax with square brackets:
        
            $[ EXPRESSION ]

        However, this will only calculate the result of EXPRESSION, and do no tests
        
        See Bash guides for more details.

    7) Process substitution

       Process substitution is supported on systems that support named pipes (FIFOs) or the /dev/fd method of
       naming open files. It takes the form of

           <(LIST)
           or
           >(LIST)

       The process LIST is run with its input or output connected to a FIFO or some file in /dev/fd. The name of
       this file is passed as an argument to the current command as the result of the expansion. If the ">(LIST)" form
       is used, writing to the file will provide input for LIST. If the "<(LIST)" form is used, the file passed as an
       argument should be read to obtain the output of LIST. Note that no space may appear between the < or >
       signs and the left parenthesis, otherwise the construct would be interpreted as a redirection.
       When available, process substitution is performed simultaneously with parameter and variable expansion,
       command substitution, and arithmetic expansion.

    8) Word splitting

        The shell scans the results of parameter expansion, command substitution, and arithmetic expansion that did
        not occur within double quotes for word splitting.

        The shell treats each character of $IFS as a delimiter, and splits the results of the other expansions into words
        on these characters. If IFS is unset, or its value is exactly "'<space><tab><newline>'", the default, then any
        sequence of IFS characters serves to delimit words. If IFS has a value other than the default, then sequences
        of the whitespace characters "space" and "Tab" are ignored at the beginning and end of the word, as long as
        the whitespace character is in the value of IFS (an IFS whitespace character). Any character in IFS that is
        not IFS whitespace, along with any adjacent IF whitespace characters, delimits a field. A sequence of IFS
        whitespace characters is also treated as a delimiter. If the value of IFS is null, no word splitting occurs.

        Explicit null arguments ("""" or "''") are retained. Unquoted implicit null arguments, resulting from the
        expansion of parameters that have no values, are removed. If a parameter with no value is expanded within
        double quotes, a null argument results and is retained.

        If no expansion occurs, no splitting is performed.

    9) File name expansion

        After word splitting, unless the -f option has been set (see Section 2.3.2), Bash scans each word for the
        characters "*", "?", and "[". If one of these characters appears, then the word is regarded as a PATTERN, and
        replaced with an alphabetically sorted list of file names matching the pattern. If no matching file names are
        found, and the shell option nullglob is disabled, the word is left unchanged. If the nullglob option is
        set, and no matches are found, the word is removed. If the shell option nocaseglob is enabled, the match is
        performed without regard to the case of alphabetic characters.

        See Bash guides for more details.

    10) Aliasing

        An alias allows a string to be substituted for a word when it is used as the first word of a simple command.
        The shell maintains a list of aliases that may be set and unset with the alias and unalias built-in commands.
        Issue the alias without options to display a list of aliases known to the current shell.

            alias e='vi'    

        In a script, aliases have very limited usefulness. It would be nice if aliases could assume some of the
        functionality of the C preprocessor, such as macro expansion, but unfortunately Bash does not expand
        arguments within the alias body. [117] Moreover, a script fails to expand an alias itself within "compound
        constructs," such as if/then statements, loops, and functions. An added limitation is that an alias will not
        expand recursively. Almost invariably, whatever we would like an alias to do could be accomplished much
        more effectively with a function.

        Aliases are not expanded when the shell is not interactive, unless the expand_aliases option is set using
        the shopt shell built-in.

        Aliases are not inherited by child processes. Bourne shell (sh) does not recognize aliases.

        See Bash guides for more details.

- display all shell options

    set -o

- changing shell options

        bash --posix script.sh  (e.g.)

    For changing the current environment temporarily, or for use in a script, we would rather use set. Use - (dash)
    for enabling an option, + for disabling

        set -o noclobber   (e.g.)

- Tests

    - Bash has the test command, various bracket and parenthesis operators, and the if/then construct.

    - There exists a dedicated command called [ (left bracket special character). It is a synonym for test,
      and a builtin for efficiency reasons. This command considers its arguments as comparison expressions
      or file tests and returns an exit status corresponding to the result of the comparison (0 for true, 1 for
      false).

    - With version 2.02, Bash introduced the [[ ... ]] extended test command, which performs comparisons
      in a manner more familiar to programmers from other languages. Note that [[ is a keyword, not a
      command.

            Bash sees [[ $a -lt $b ]] as a single element, which returns an exit status.

    - The (( ... )) and let ... constructs return an exit status, according to whether the arithmetic expressions
      they evaluate expand to a non-zero value. These arithmetic-expansion constructs may therefore be
      used to perform arithmetic comparisons.

    - The [[ ]] construct is the more versatile Bash version of [ ]. This is the extended test command, adopted from
      ksh88.

      No filename expansion or word splitting takes place between [[ and ]], but there is parameter expansion and
      command substitution.

      Using the [[ ... ]] test construct, rather than [ ... ] can prevent many logic errors in scripts. For example, the
      &&, ||, <, and > operators work within a [[ ]] test, despite giving an error within a [ ] construct.

      The (( )) construct expands and evaluates an arithmetic expression. If the expression evaluates as zero, it
      returns an exit status of 1, or "false". A non-zero expression returns an exit status of 0, or "true". This is in
      marked contrast to using the test and [ ] constructs previously discussed.

- conditional statements

    - An if/then construct tests whether the exit status of a list of commands is 0 (since 0 means "success"
      by UNIX convention), and if so, executes one or more commands.

    - An if can test any command, not just conditions enclosed within brackets.

    - Following an if, neither the test command nor the test brackets ( [ ] or [[ ]] ) are strictly necessary.

    if TEST-COMMANDS; then CONSEQUENT-COMMANDS; fi

    if TEST-COMMANDS; then CONSEQUENT-COMMANDS; else ALTERNATE-CONSEQUENT-COMMANDS;  fi

    if TEST-COMMANDS; then
    CONSEQUENT-COMMANDS;
    elif MORE-TEST-COMMANDS; then
    MORE-CONSEQUENT-COMMANDS;
    else ALTERNATE-CONSEQUENT-COMMANDS;
    fi

    C-style trinary operator. [17]
    
        condition?result-if-true:result-if-false
        (( var0 = var1<98?9:21 ))

    - Inside the if statement, you can use another if statement. You may use as many levels of nested ifs as you can
      logically manage.

    - The TEST-COMMAND list is executed, and if its return status is zero, the CONSEQUENT-COMMANDS
      list is executed. The return status is the exit status of the last command executed, or zero if no condition tested
      true. The TEST-COMMAND often involves numerical or string comparison tests, but it can also be any command
      that returns a status of zero when it succeeds and some other status when it fails.

            Primary                     Meaning
            -------                     -------
            [ -a FILE ]                 True if FILE exists. (This is identical in effect to -e. It has been "deprecated," and its use is discouraged.)
            [ -b FILE ]                 True if FILE exists and is a block-special file. (block device)
            [ -c FILE ]                 True if FILE exists and is a character-special file.  (character device)
            [ -d FILE ]                 True if FILE exists and is a directory.
            [ -e FILE ]                 True if FILE exists.
            [ -f FILE ]                 True if FILE exists and is a regular file. (not a directory or device file)
            [ -g FILE ]                 True if FILE exists and its SGID bit is set.
            [ -h FILE ]                 True if FILE exists and is a symbolic link.
            [ -k FILE ]                 True if FILE exists and its sticky bit is set.
            [ -p FILE ]                 True if FILE exists and is a named pipe (FIFO).
            [ -r FILE ]                 True if FILE exists and is readable.
            [ -s FILE ]                 True if FILE exists and has a size greater than zero.
            [ -t FD ]                   True if file descriptor FD is open and refers to a terminal.
            [ -u FILE ]                 True if FILE exists and its SUID (set user ID) bit is set.
            [ -w FILE ]                 True if FILE exists and is writable.
            [ -x FILE ]                 True if FILE exists and is executable.
            [ -O FILE ]                 True if FILE exists and is owned by the effective user ID.
            [ -G FILE ]                 True if FILE exists and is owned by the effective group ID
            [ -L FILE ]                 True if FILE exists and is a symbolic link.
            [ -N FILE ]                 True if FILE exists and has been modified since it was last read.
            [ -S FILE ]                 True if FILE exists and is a socket.
            [ FILE1 -nt FILE2 ]         True if FILE1 has been changed more recently than FILE2, or if FILE1 exists and FILE2 does not.
            [ FILE1 -ot FILE2 ]         True if FILE1 is older than FILE2, or is FILE2 exists and FILE1 does not.
            [ FILE1 -ef FILE2 ]         True if FILE1 and FILE2 refer to the same device and inode numbers.
            [ -o OPTIONNAME ]           True if shell option "OPTIONNAME" is enabled.
            [ -z STRING ]               True if the length if "STRING" is zero.
            [ -n STRING ] or [STRING ]  True if the length of "STRING" is non-zero.
            [ STRING1 == STRING2 ]      True if the strings are equal. "=" may be used instead of "==" for strict POSIX compliance.
            [ STRING1 != STRING2 ]      True if the strings are not equal.
            [ STRING1 < STRING2 ]       True if "STRING1" sorts before "STRING2" lexicographically in the current locale.
            [ STRING1 > STRING2 ]       True if "STRING1" sorts after "STRING2" lexicographically in the current locale.
            [ ARG1 OP ARG2 ]            "OP" is one of -eq, -ne, -lt, -le, -gt or -ge. These arithmetic binary operators
                                        return true if "ARG1" is equal to, not equal to, less than, less than or equal to, greater
                                        than, or greater than or equal to "ARG2", respectively. "ARG1" and "ARG2" are integers.

            - Note that = can be either an assignment or a test operator, depending on context.

            - Always quote a tested string.

                if [ -z "$String" ]

    - Expressions may be combined using the following operators, listed in decreasing order of precedence:

            Operation               Effect
            ---------               ------
            [ ! EXPR ]              True if EXPR is false.
            [ ( EXPR ) ]            Returns the value of EXPR. This may be used to override the normal precedence of operators.
            [ EXPR1 -a EXPR2 ]      True if both EXPR1 and EXPR2 are true.
            [ EXPR1 -o EXPR2 ]      True if either EXPR1 or EXPR2 is true.

    - "&&" expression indicates what to do if the test proves true, 
      "||" specifies what to do if the test is false.

    - Regular expressions may also be used in comparisons:


    - commands following the then statement

        The CONSEQUENT-COMMANDS list that follows the then statement can be any valid UNIX command,
        any executable program, any executable shell script or any shell statement, with the exception of the closing
        fi. It is important to remember that the then and fi are considered to be separated statements in the shell.
        Therefore, when issued on the command line, they are separated by a semi-colon.
    
    -  Most programmers will prefer to use the test built-in command, which is equivalent to using square
       brackets for comparison, like this:

            test "$(whoami)" != 'root' && (echo you are using a non-privileged account; exit 1)

            - If you invoke the exit in a subshell, it will not pass variables to the parent. Use { and } instead of ( and )
              if you do not want Bash to fork a subshell.

    - examples

        - if [ -f /var/log/messages ]
            then
               echo "/var/log/messages exists."
          fi

        - if [ "$1" == fish]; then
            echo "Hmm fish"
          else
            echo "want fish"
          fi

- case statement

        case "$variable" in

        "$condition1" )
        command...
        ;;

        "$condition2" )
        command...
        ;;

        esac

    - Each case is an expression matching a pattern. The commands in the COMMAND-LIST for the first match
      are executed. The "|" symbol is used for separating multiple patterns, and the ")" operator terminates a pattern
      list. Each case plus its according commands are called a clause. Each clause must be terminated with ";;".
      Each case statement is ended with the esac statement.

    - Quoting the variables is not mandatory, since word splitting does not take
      place.

    - A case construct can filter strings for globbing patterns

- exit statement

    It terminates execution of the entire script. It is most often used if the input requested from the user is incorrect, if a statement did
    not run successfully or if some other error occurred. The exit statement takes an optional argument. This argument is the integer exit status
    code, which is passed back to the parent and stored in the $? variable.

    A zero argument means that the script ran successfully. Any other value may be used by programmers to pass
    back different messages to the parent, so that different actions can be taken according to failure or success of
    the child process. If no argument is given to the exit command, the parent shell uses the current value of the
    $? variable.

- regular expressions

    See Bash guides for more details.

- sed

    A Stream EDitor is used to perform basic transformations on text read from a file or a pipe. The result is sent
    to standard output.

- awk

    The command awk allows searching data in a file and printing data on the console.  If a file contains multiple columns,
    then it is also possible to find data in specific columns. Furthermore, it helps tasks such as searching, conditional execution,
    updating and filtering.

- sed vs awk

    The main difference between sed and awk is that sed is a command utility that works with streams of characters 
    for searching, filtering and text processing while awk more powerful and robust than sed with sophisticated 
    programming constructs such as if/else, while, do/while etc.

- interactive scripts

    - output

        - exit

            The echo built-in command outputs its arguments, separated by spaces and terminated with a newline
            character. The return status is always zero. echo takes a couple of options:

                • -e: interprets backslash-escaped characters.
                • -n: suppresses the trailing newline.

        - escape sequences

            Sequence        Meaning
            --------        -------
            \a              Alert (bell).
            \b              Backspace.
            \c              Suppress trailing newline.
            \e              Escape.
            \f              Form feed.
            \n              Newline. (*)
            \r              Carriage return.
            \t              Horizontal tab.
            \v              Vertical tab.
            \\              Backslash.
            \0NNN           The eight-bit character whose value is the octal value NNN (zero to three octal digits).
            \NNN            The eight-bit character whose value is the octal value NNN (one to three octal digits).
            \xHH            The eight-bit character whose value is the hexadecimal value (one or two hexadecimal digits).

    - user input

        - read built-in command

            read [options] NAME1 NAME2 ... NAMEN

                One line is read from the standard input, or from the file descriptor supplied as an argument to the -u option.
                The first word of the line is assigned to the first name, NAME1, the second word to the second name, and so
                on, with leftover words and their intervening separators assigned to the last name, NAMEN. If there are fewer
                words read from the input stream than there are names, the remaining names are assigned empty values.

                The characters in the value of the IFS variable are used to split the input line into words or tokens;
                The backslash character may be used to remove any special meaning for the next character read
                and for line continuation.
                If no names are supplied, the line read is assigned to the variable REPLY.
                The return code of the read command is zero, unless an end-of-file character is encountered, if read times out
                or if an invalid file descriptor is supplied as the argument to the -u option.

                See Bash documentation for option switches

- Redirection and file descriptors

    As you know from basic shell usage, input and output of a command may be redirected before it is executed,
    using a special notation - the redirection operators - interpreted by the shell. Redirection may also be used to
    open and close files for the current shell execution environment.

    In bash, standard error can be redirected on the command line. Redirecting stderr can be useful if you need to
    capture any error messages to a separate log file, or hide the error messages entirely.

    Redirection can also occur in a script, so that it can receive input from a file, for instance, or send output to a
    file. Later, the user can review the output file, or it may be used by another script as input.

    File input and output are accomplished by integer handles that track all open files for a given process. These
    numeric values are known as file descriptors. The best known file descriptors are stdin, stdout and stderr, with
    file descriptor numbers 0, 1 and 2, respectively. These numbers and respective devices are reserved. Bash can
    take TCP or UDP ports on networked hosts as file descriptors as well.

    When excuting a given command, the following steps are excuted, in order:
    
    • If the standard output of a previous command is being piped to the standard input of the current
    command, then /proc/<current_process_ID>/fd/0 is updated to target the same
    anonymous pipe as /proc/<previous_process_ID/fd/1.
    • If the standard output of the current command is being piped to the standard input of the next
    command, then /proc/<current_process_ID>/fd/1 is updated to target another
    anonymous pipe.
    • Redirection for the current command is processed from left to right.
    • Redirection "N>&M" or "N<&M" after a command has the effect of creating or updating the
    symbolic link /proc/self/fd/N with the same target as the symbolic link /proc/self/fd/M.
    • The redirections "N> file" and "N< file" have the effect of creating or updating the symbolic link
    /proc/self/fd/N with the target file.
    • File descriptor closure "N>&-" has the effect of deleting the symbolic link /proc/self/fd/N.
    • Only now is the current command executed.

    -from ABS

        There are always three default files open, stdin (the keyboard), stdout (the screen), and stderr
        (error messages output to the screen). These, and any other open files, can be redirected. Redirection simply
        means capturing output from a file, command, program, script, or even code block within a script
         and sending it as input to another file, command, program, or script.
        Each open file gets assigned a file descriptor. The file descriptors for stdin, stdout, and stderr
        are 0, 1, and 2, respectively. For opening additional files, there remain descriptors 3 to 9. It is sometimes
        useful to assign one of these additional file descriptors to stdin, stdout, or stderr as a temporary
        duplicate link. This simplifies restoration to normal after complex redirection and reshuffling.

            COMMAND_OUTPUT >
            # Redirect stdout to a file.
            # Creates the file if not present, otherwise overwrites it.

            ls -lR > dir-tree.list
            # Creates a file containing a listing of the directory tree.

            : > filename
            # The > truncates file "filename" to zero length.
            # If file not present, creates zero-length file (same effect as 'touch').
            # The : serves as a dummy placeholder, producing no output.

            > filename
            # The > truncates file "filename" to zero length.
            # If file not present, creates zero-length file (same effect as 'touch').
            # (Same result as ": >", above, but this does not work with some shells.)

            COMMAND_OUTPUT >>
            # Redirect stdout to a file.
            # Creates the file if not present, otherwise appends to it.

            # Single-line redirection commands (affect only the line they are on):
            # --------------------------------------------------------------------
            
            1>filename
            # Redirect stdout to file "filename."

            1>>filename
            # Redirect and append stdout to file "filename."

            2>filename
            # Redirect stderr to file "filename."

            2>>filename
            # Redirect and append stderr to file "filename."

            &>filename
            # Redirect both stdout and stderr to file "filename."
            # This operator is now functional, as of Bash 4, final release.

            M>N
            # "M" is a file descriptor, which defaults to 1, if not explicitly set.
            # "N" is a filename.
            # File descriptor "M" is redirect to file "N."

            M>&N
            # "M" is a file descriptor, which defaults to 1, if not set.
            # "N" is another file descriptor.

            >&j
            # Redirects, by default, file descriptor 1 (stdout) to j.
            # All stdout gets sent to file pointed to by j.

            0< FILENAME
            < FILENAME
            # Accept input from a file.

            [j]<>filename
            # Open file "filename" for reading and writing,
            #+ and assign file descriptor "j" to it.
            # If "filename" does not exist, create it.
            # If file descriptor "j" is not specified, default to fd 0, stdin.

            Closing File Descriptors

                n<&-        Close input file descriptor n.
                0<&-, <&-   Close stdin.
                n>&-        Close output file descriptor n.
                1>&-, >&-   Close stdout.

                    Child processes inherit open file descriptors. This is why pipes work. To prevent an fd from being inherited,
                    close it.

- help vs man vs info

    help is a built-in command in the bash shell (and that shell only) that documents some of the builtin commands
     and keywords of that shell. That's an internal documentation system of that shell. Other shells have their own
     documentation system (ksh93 has --help and --man options for its builtins, zsh has a run-help helper that extracts
    information from manuals in other formats). Other commands like vim have their own embedded documentation system.

    man is a system-wide documentation system that provides short reference manuals (pages) for individual commands,
    API functions, concepts, configuration file syntax, file formats organised in sections (1 for user commands, 2 for system
    calls...). That's the traditional Unix documentation system.

    info is another documentation system originating in the GNU project. It's hypertext with links (predates the web). An info
    manual is like a digital book with a concept of table of contents and (searchable) index which helps locating the information.

    There's overlap between the 3. For instance, bash being part of the GNU project has both a man page and an info manual. 
    The size of the manual makes the man system not as appropriate for bash though. However, the structure of the info manual
    and index is not very good in bash which makes it not as easy to look information in as in other info manuals like zsh's. 
    zsh manual being even bigger is split into several man pages and also has a good info manual with a very good index.

    It should be noted that the info manual is generated from a texinfo format which is also used to generate HTML and printable
   (PDF/PS) versions. In the case of zsh though, the texinfo is generated from another format (yodl).

- looping

    - for loop    
    - while loop
    - until loop

    - break & break N
    - continue & continue N

- for loop

        for NAME [in LIST ]; do COMMANDS; done

    The argument LIST may contain wild cards.

    If [in LIST] is not present, it is replaced with in $@ and for executes the COMMANDS once for each
    positional parameter that is set (see Section 3.2.5 and Section 7.2.1.2)

    The return status is the exit status of the last command that executes. If no commands are executed because
    LIST does not expand to any items, the return status is zero.

    NAME can be any variable name, although i is used very often. LIST can be any list of words, strings or
    numbers, which can be literal or generated by any command.

- while loop

        while CONTROL-COMMAND; do CONSEQUENT-COMMANDS; done

    The while construct allows for repetitive execution of a list of commands, as long as the command controlling
    the while loop executes successfully (exit status of zero).

    CONTROL-COMMAND can be any command(s) that can exit with a success or failure status. The
    CONSEQUENT-COMMANDS can be any program, script or shell construct.

    The return status is the exit status of the last CONSEQUENT-COMMANDS command, or zero if none was
    executed.

- until loop

        until TEST-COMMAND; do CONSEQUENT-COMMANDS; done

    The until loop is very similar to the while loop, except that the loop executes until the TEST-COMMAND
    executes successfully. As long as this command fails, the loop continues

- Making menus with the select built-in

    The select construct allows easy menu generation. The syntax is quite similar to that of the for loop:

        select WORD [in LIST]; do RESPECTIVE-COMMANDS; done

    LIST is expanded, generating a list of items. The expansion is printed to standard error; each item is preceded
    by a number. If in LIST is not present, the positional parameters are printed, as if in $@ would have been
    specified. LIST is only printed once.

        select variable [in list]
        do
          command...
          break
        done

    This prompts the user to enter one of the choices presented in the variable list. Note that select uses
    the $PS3 prompt (#? ) by default, but this may be changed.

    If in list is omitted, then select uses the list of command line arguments ($@) passed to the script
    or the function containing the select construct.

- shift

    The shift command reassigns the positional parameters, in effect shifting them to the left one notch.
    $1 <--- $2, $2 <--- $3, $3 <--- $4, etc.
    The old $1 disappears, but $0 (the script name) does not change. If you use a large number of
    positional parameters to a script, shift lets you access those past 10, although {bracket} notation also
    permits this.

    The shift command is one of the Bourne shell built-ins that comes with Bash. This command takes one
    argument, a number. The positional parameters are shifted to the left by this number, N. The positional
    parameters from N+1 to $# are renamed to variable names from $1 to $# - N+1.

    A shift statement is typically used when the number of arguments to a command is not known in advance, for
    instance when users can give as many arguments as they like. In such cases, the arguments are usually
    processed in a while loop with a test condition of (( $# )).

- xargs

    The xargs command builds and executes command lines from standard input. This has the advantage
    that the command line is filled until the system limit is reached. 

     In its most basic form - reads data from standard input (stdin) and executes the command
     (supplied to it as an argument) one or more times based on the input read. Any blanks and spaces
     in the input are treated as delimiters, while blank lines are ignored. 

- declare

    Using a declare statement, we can limit the value assignment to variables.

    The syntax for declare is the following:

        declare OPTION(s) VARIABLE=value

        Option Meaning
        ------ -------
        -a          Variable is an array.
        -f          Use function names only.
        -i          The variable is to be treated as an integer; arithmetic evaluation is performed when the variable is assigned a value (see Section 3.4.6).
        -p          Display the attributes and values of each variable. When -p is used, additional options are ignored.
        -R          Make variables read-only. These variables cannot then be assigned values by subsequent assignment
                    statements, nor can they be unset.
        -t          Give each variable the trace attribute.
        -x          Mark each variable for export to subsequent commands via the environment.

        Using + instead of - turns off the attribute instead. When used in a function, declare creates local variables.

    Note that Bash has an option to declare a numeric value, but none for declaring string values. This is because,
    by default, if no specifications are given, a variable can hold any type of data

- readonly variables

    In Bash, constants are created by making a variable read-only. The readonly built-in marks each specified
    variable as unchangeable. The syntax is:

        readonly OPTION VARIABLE(s)

    The values of these variables can then no longer be changed by subsequent assignment. If the -f option is
    given, each variable refers to a shell function;

- Array variables

    Newer versions of Bash support one-dimensional arrays. Array elements may be initialized with the
    variable[xx] notation. Alternatively, a script may introduce the entire array by an explicit declare -a
    variable statement. To dereference (retrieve the contents of) an array element, use curly bracket notation,
    that is, ${element[xx]}.

    Bash provides one-dimensional indexed and associative array variables. Any variable may be used as an indexed array;
    the declare builtin will explicitly declare an array. There is no maximum limit on the size of an array, nor any requirement
    that members be indexed or assigned contiguously. Indexed arrays are referenced using integers (including arithmetic expressions
    (see Shell Arithmetic)) and are zero-based; associative arrays use arbitrary strings. Unless otherwise noted, indexed array
     indices must be non-negative integers.

    An indexed array is created automatically if any variable is assigned to using the syntax

        name[subscript]=value

    The subscript is treated as an arithmetic expression that must evaluate to a number. To explicitly declare an array, use

        declare -a name

    The syntax

        declare -a name[subscript]

    is also accepted; the subscript is ignored.

    Associative arrays are created using

        declare -A name.

    Attributes may be specified for an array variable using the declare and readonly builtins. Each attribute applies to all members of an array. 

    An array is a variable containing multiple values. Any variable may be used as an array. There is no
    maximum limit to the size of an array, nor any requirement that member variables be indexed or assigned
    contiguously. Arrays are zero-based: the first element is indexed with the number 0.

    Indirect declaration is done using the following syntax to declare a variable:

        ARRAY[INDEXNR]=value
    
    The INDEXNR is treated as an arithmetic expression that must evaluate to a positive number.

    Array members need not be consecutive or contiguous.
    Some members of the array can be left uninitialized.
    Gaps in the array are okay.

    Array variables have a syntax all their own, and even standard Bash commands and operators have special
    options adapted for array use.

    Explicit declaration of an array is done using the declare built-in:

        declare -a ARRAYNAME

    A declaration with an index number will also be accepted, but the index number will be ignored. Attributes to
    the array may be specified using the declare and readonly built-ins. Attributes apply to all variables in the
    array; you can't have mixed arrays.

    Array variables may also be created using compound assignments in this format:

        ARRAY=(value1 value2 ... valueN)

    Each value is then in the form of [indexnumber=]string. The index number is optional. If it is supplied, that
    index is assigned to it; otherwise the index of the element assigned is the number of the last index that was
    assigned, plus one. This format is accepted by declare as well. If no index numbers are supplied, indexing
    starts at zero.

    Adding missing or extra members in an array is done using the syntax:

       ARRAYNAME[indexnumber]=value

    Remember that the read built-in provides the -a option, which allows for reading and assigning values for
    member variables of an array.

    Dereferencing the variables in an array

        In order to refer to the content of an item in an array, use curly braces. This is necessary
        bypass the shell interpretation of expansion operators. If the index number is @ or
        *, all members of an array are referenced.

            ARRAY=(one two three)
            echo ${ARRAY[*]}
            one two three
            echo $ARRAY[*]
            one[*]
            echo ${ARRAY[2]}
            three
            ARRAY[3]=four
            echo ${ARRAY[*]}
            one two three four

        Referring to the content of a member variable of an array without providing an index number is the same as
        referring to the content of the first element, the one referenced with index number zero.

    The unset built-in is used to destroy arrays or member variables of an array:

        unset ARRAY[1]
        echo ${ARRAY[*]}
        one three four
        unset ARRAY
        echo ${ARRAY[*]}
        <--no output-->

- Length of a variable

    Using the ${#VAR} syntax will calculate the number of characters in a variable.

- functions

    Shell functions are a way to group commands for later execution, using a single name for this group, or
    routine. The name of the routine must be unique within the shell or script. All the commands that make up a
    function are executed like regular commands. When calling on a function as a simple command name, the list
    of commands associated with that function name is executed. A function is executed within the shell in which
    it has been declared: no new process is created to interpret the commands.

    Functions either use the syntax

        function FUNCTION_NAME { COMMANDS; }

    or

        function FUNCTION_NAME () { COMMANDS; }

    Both define a shell function FUNCTION. The use of the built-in command function is optional; however, if
    it is not used, parentheses are needed.

    The curly braces must be separated from the body by spaces, otherwise they are interpreted in the wrong
    way.

    The body of a function should end in a semicolon or a newline.

    Functions are like mini-scripts: they can accept parameters, they can use variables only known within the
    function (using the local shell built-in) and they can return values to the calling shell.

    A function also has a system for interpreting positional parameters. However, the positional parameters passed
    to a function are not the same as the ones passed to a command or script.

    When a function is executed, the arguments to the function become the positional parameters during its
    execution. The special parameter # that expands to the number of positional parameters is updated to reflect
    the change. Positional parameter 0 is unchanged. The Bash variable FUNCNAME is set to the name of the
    function, while it is executing.

    If the return built-in is executed in a function, the function completes and execution resumes with the next
    command after the function call. When a function completes, the values of the positional parameters and the
    special parameter # are restored to the values they had prior to the function's execution. If a numeric argument
    is given to return, that status is returned.

    Note that the return value or exit code of the function is often storen in a variable, so that it can be probed at a
    later point. The init scripts on your system often use the technique of probing the RETVAL variable in a
    conditional test, like this one:

        if [ $RETVAL -eq 0 ]; then
            <start the daemon>

    Or like this example from the /etc/init.d/amd script, where Bash's optimization features are used:

        [ $RETVAL = 0 ] && touch /var/lock/subsys/amd

    The function definition must precede the first call to it. There is no method of "declaring" the function, as, for
    example, in C.

    It is even possible to nest a function within another function, although this is not very useful.

    Functions may process arguments passed to them and return an exit status to the script for further processing.

        function_name $arg1 $arg2

    The function refers to the passed arguments by position (as if they were positional parameters), that is, $1,
    $2, and so forth.

    In contrast to certain other programming languages, shell scripts normally pass only value parameters to
    functions. Variable names (which are actually pointers), if passed as parameters to functions, will be treated
    as string literals. Functions interpret their arguments literally.

    Indirect variable references (see Example 37-2) provide a clumsy sort of mechanism for passing variable
    pointers to functions.

    Functions return a value, called an exit status. This is analogous to the exit status returned by a
    command. The exit status may be explicitly specified by a return statement, otherwise it is the exit
    status of the last command in the function (0 if successful, and a non-zero error code if not). This exit
    status may be used in the script by referencing it as $?. This mechanism effectively permits script
    functions to have a "return value" similar to C functions.

    For a function to return a string or array, use a dedicated variable.

        count_lines_in_etc_passwd()
        {
            [[ -r /etc/passwd ]] && REPLY=$(echo $(wc -l < /etc/passwd))
            # If /etc/passwd is readable, set REPLY to line count.
            # Returns both a parameter value and status information.
            # The 'echo' seems unnecessary, but . . .
            #+ it removes excess whitespace from the output.
        }

        if count_lines_in_etc_passwd
        then
            echo "There are $REPLY lines in /etc/passwd."
        else
            echo "Cannot count lines in /etc/passwd."
        fi

    The largest positive integer a function can return is 255. The return command is closely
    tied to the concept of exit status, which accounts for this particular limitation. Fortunately,
    there are various workarounds for those situations requiring a large integer return value
    from a function.

    A workaround for obtaining large integer "return values" is to simply assign the "return
    value" to a global variable.

        Return_Val=
        # Global variable to hold oversize return value of function.
        
        alt_return_test ()
        {
        fvar=$1
        Return_Val=$fvar
        return
        # Returns 0 (success).
        }

    A more elegant method is to have the function echo its "return value to stdout," and then
    capture it by command substitution.

        func_name ()
        {
            retval= ...  # local?
            echo $retval
            # Echoes (to stdout), rather than returning value.
        }

        return_val=$(funcname param1 param2)

    - Local Variables

        A variable declared as local is one that is visible only within the block of code in which it appears. It
        has local scope. In a function, a local variable has meaning only within that function block. [110]

            #!/bin/bash

            func ()
            {
                local loc_var=23    # Declared as local variable.

                echo
                # Uses the 'local' builtin.
                echo "\"loc_var\" in function = $loc_var"

                global_var=999
                # Not declared as local.
                # Therefore, defaults to global.
                echo "\"global_var\" in function = $global_var"
            }

- ${parameter}

    Same as $parameter, i.e., value of the variable parameter. In certain contexts, only the less
    ambiguous ${parameter} form works.

    May be used for concatenating variables with strings.

- ${parameter-default}, ${parameter:-default}

    If parameter not set, use default.

    ${parameter-default} and ${parameter:-default} are almost
    equivalent. The extra : makes a difference only when parameter has been declared,
    but is null.

    The default parameter construct finds use in providing "missing" command-line arguments in scripts.

- ${parameter=default}, ${parameter:=default}

    If parameter not set, set it to default.

    Both forms nearly equivalent. The : makes a difference only when $parameter has been declared
    and is null.

- Arithmetic expansion

    Arithmetic expansion provides a powerful tool for performing (integer) arithmetic operations in scripts.
    Translating a string into a numerical expression is relatively straightforward using backticks, double
    parentheses, or let.

    - backticks

        often used in conjunction with expr)

            z=`expr $z + 3`    # The 'expr' command performs the expansion.

    - The use of backticks (backquotes) in arithmetic expansion has been superseded by double parentheses
      -- ((...)) and $((...)) -- and also by the very convenient let construction.

        z=$(($z+3))
        z=$((z+3))          #  Also correct.
                            #  Within double parentheses,
                            #+ parameter dereferencing
                            #+ is optional.

        # $((EXPRESSION)) is arithmetic expansion.   # Not to be confused with
                                                     #+ command substitution.

        # You may also use operations within double parentheses without assignment.

         n=0
         echo "n = $n"  # n = 0

         (( n += 1 ))   # Increment
                        # (( $n += 1 )) is incorrect!
         echo "n = $n"  # n = 1

        let z=z+3
        let "z += 3"    #  Quotes permit the use of spaces in variable assignment.
                        #  The 'let' operator actual
                        #+ rather than expansion.

- Process Substitution

    Piping the stdout of a command into the stdin of another is a powerful technique. But, what if you need
    to pipe the stdout of multiple commands? This is where process substitution comes in.
    Process substitution feeds the output of a process (or processes) into the stdin of another process.

    - Template

        Command list enclosed within parentheses

            >(command_list)
            <(command_list)

    Process substitution uses /dev/fd/<n> files to send the results of the process(es) within
    parentheses to another process.

    There is no space between the the "<" or ">" and the parentheses. Space there would
    give an error message.

- List Constructs

    The and list and or list constructs provide a means of processing a number of commands consecutively. These
    can effectively replace complex nested if/then or even case statements.
    
    Chaining together commands

        and list

            command-1 && command-2 && command-3 && ... command-n

            Each command executes in turn, provided that the previous command has given a return value of
            true (zero). At the first false (non-zero) return, the command chain terminates (the first command
            returning false is the last one to execute).            

        or list

            command-1 || command-2 || command-3 || ... command-n

                Each command executes in turn for as long as the previous command returns false. At the first true
                return, the command chain terminates (the first command returning true is the last one to execute).
                This is obviously the inverse of the "and list".

        The exit status of an and list or an or list is the exit status of the last command executed.
        Clever combinations of and and or lists are possible, but the logic may easily become convoluted and require
        close attention to operator precedence rules, and possibly extensive debugging.

- Indirect References

    We have seen that referencing a variable, $var, fetches its value. But, what about the value of a value? What
    about $$var?

    The actual notation is \$$var, usually preceded by an eval (and sometimes an echo). This is called an
    indirect reference.

    Indirect referencing in Bash is a multi-step process. First, take the name of a variable: varname. Then,
    reference it: $varname. Then, reference the reference: $$varname. Then, escape the first $:
    \$$varname. Finally, force a reevaluation of the expression and assign it: eval newvar=\$$varname.

    Of what practical use is indirect referencing of variables? It gives Bash a little of the functionality of pointers
    in C, for instance, in table lookup. And, it also has some other very interesting applications. . . .

- /dev/null

    Think of /dev/null as a black hole. It is essentially the equivalent of a write-only file. Everything
    written to it disappears. Attempts to read or output from it result in nothing. All the same,
    /dev/null can be quite useful from both the command-line and in scripts.

    # Suppressing stdout.
    cat $filename >/dev/null

    # Suppressing stderr
    rm $badname 2>/dev/null

    # Suppressing output from both stdout and stderr.
    cat $filename 2>/dev/null >/dev/null

- /dev/zero

    Like /dev/null, /dev/zero is a pseudo-device file, but it actually produces a stream of nulls
    (binary zeros, not the ASCII kind). Output written to /dev/zero disappears, and it is fairly difficult
    to actually read the nulls emitted there, though it can be done with od or a hex editor. The chief use of
    /dev/zero is creating an initialized dummy file of predetermined length intended as a temporary
    swap file.

- gotchas

    - Using whitespace inappropriately. In contrast to other programming languages, Bash can be quite
      finicky about whitespace.

        var1 = 23
        # 'var1=23' is correct.
        # On line above, Bash attempts to execute command "var1"
        # with the arguments "=" and "23".

    - Not terminating with a semicolon the final command in a code block within curly brackets.

        { ls -l; df; echo "Done." }
        # bash: syntax error: unexpected end of file
        ### Final command needs semicolon.
        { ls -l; df; echo "Done."; }

    - Assuming uninitialized variables (variables before a value is assigned to them) are "zeroed out". An
      uninitialized variable has a value of null, not zero.

        #!/bin/bash
        echo "uninitialized_var = $uninitialized_var"
        # uninitialized_var =
        # However . . .
        # if $BASH_VERSION ≥ 4.2; then
        if [[ ! -v uninitialized_var ]]
        then
           uninitialized_var=0
            # Initialize it to zero!
        fi

    - Mixing up = and -eq in a test. Remember, = is for comparing literal variables and -eq for integers

    - Misusing string comparison operators.

        Numerical and string comparison are not equivalent

    - Attempting to use let to set string variables.

    - Sometimes variables within "test" brackets ([ ]) need to be quoted (double quotes). Failure to do so
      may cause unexpected behavior.

    - Quoting a variable containing whitespace prevents splitting. Sometimes this produces unintended
      consequences.

    - Using Bash-specific functionality in a Bourne shell script (#!/bin/sh) on a non-Linux machine
      may cause unexpected behavior. A Linux system usually aliases sh to bash, but this does not
      necessarily hold true for a generic UNIX machine.
    
    - A script with DOS-type newlines (\r\n) will fail to execute, since #!/bin/bash\r\n is not
      recognized, not the same as the expected #!/bin/bash\n. The fix is to convert the script to
      UNIX-style newlines.

    - A shell script headed by #!/bin/sh will not run in full Bash-compatibility mode. Some
      Bash-specific functions might be disabled. Scripts that need complete access to all the Bash-specific
      extensions should start with #!/bin/bash.

- Hints

    - Setting the path and umask at the beginning of a script makes it more portable -- more likely to run on
      a "foreign" machine whose user may have bollixed up the $PATH and umask.

- Style

    - Use standardized parameter flags for script invocation. Ender proposes the following set of flags.

        -a        All: Return all information (including hidden file info).
        -b        Brief: Short version, usually for other scripts.
        -c        Copy, concatenate, etc.
        -d        Daily: Use information from the whole day, and not merely
                  information for a specific instance/user.
        -e        Extended/Elaborate: (often does not include hidden file info).
        -h        Help: Verbose usage w/descs, aux info, discussion, help.
                  See also -V.
        -l        Log output of script.  
        -m        Manual: Launch man-page for base command.
        -n        Numbers: Numerical data only.
        -r        Recursive: All files in a directory (and/or all sub-dirs).
        -s        Setup & File Maintenance: Config files for this script.
        -u        Usage: List of invocation flags for the script.
        -v        Verbose: Human readable output, more or less formatted.
        -V        Version / License / Copy(right|left) / Contribs (email too).

    - Break complex scripts into simpler modules. Use functions where appropriate.

    - Don't use a complex construct where a simpler one will do.

    - For tests, the [[ ]] construct may be more appropriate than [ ]. Likewise, arithmetic comparisons might
      benefit from the (( )) construct.

- history

    - !!

        repeat last entered command

    - !xyz

        run the last command beginning with xyz that you typed

    - !xyz:p

        If you need to be very sure of the command you’re targeting, :p can be a huge help. !xyz:p will print the command
        that would be executed rather than executing it. :p is also clever enough to add the printed command to your history
        list as the last command executed (even though it didn’t execute it) so that, if you decide that you like what was printed,
        a !! is all you need to make it happen.

    - !N

        type history, find the number of the command you want and then type !N where "N" is the number of the command
        you’d like to execute. (:p works here too.)

    - ctrl-r ...

         ^r (ctrl-r) followed by whatever you type will search the command history for that string. The bonus here is
         that you’re able to edit the command line you’ve searched for before you send it down the line.

    - !$

        Bang dollar-sign

        !$ is the "end" of the previous command. Consider the following example: We start by looking for a word in a file

            $ grep -i joe /some/long/directory/structure/user-lists/list-15

        if joe is in that userlist, we want to remove him from it. We can either fire up vi with that long directory tree as the argument, or as simply as

            $ vi !$

        Which bash expands to:

            $ vi /some/long/directory/structure/user-lists/list-15

        A word of caution: !$ expands to the end word of the previous command. What’s a word? The bash man page calls a word
        "A sequence of characters considered as a single unit by the shell." If you haven’t changed anything, chances are good
        that a word is a quoted string or a white-space delimited group of characters. What is a white-space delimited group of
        characters ? It’s a group of characters that are separated from other characters by some form of white-space (which could
        be a tab, space, etc.) If you’re in doubt, :p works here too.

        Another thing to keep in mind when using !$ is that if the previous command had no agruments, !$ will expand to the previous
        command rather than the most recent argument. This can be handy if, for example, you forget to type vi and you just type the
        filename. A simple vi !$ and you’re in.

    - !*

        Similar to !$ is !*. !* is all of the arguments to the previous command rather than just the last one. As usual, this is useful
        in many situations. Here’s a simple example:

            $ vi cd /stuff #(oops!)
            [exit vi twice]
            $ !*

        Which bash expands to:

            $ cd /stuff

    - tab-tab

        One of my favorite features of bash is tab-completion. Tab-completion works in a couple of ways, it can complete filenames in the
        current directory or in your $PATH. Like the !commands above, you just need to give bash enough of the filename to make it unique
        and hit the tab key — bash will do the rest for you. Let’s say you have a file in your home directory called ransom.note, consider
        the following:

            $ mor[tab] ran[tab]

        Will expand to

            $ more ransom.note

        Let’s say you also have a file named random in your home directory. ran above is no longer enough to be unique, but you’re in luck. 
        If you hit tab twice, bash will print the list of matching files to the screen so that you can see what you need to add to make your
        shortcut unique.

================================================================================================

USEFUL CODE SNIPPETS
--------------------

- the following script prolog tests whether the script has
been invoked with the correct number of parameters.

    E_WRONG_ARGS=85
    script_parameters="-a -h -m -z"
    # -a = all, -h = help, etc.
    
    if [ $# -ne $Number_of_expected_args ]
    then
        echo "Usage: `basename $0` $script_parameters"
        # `basename $0` is the script's filename.
        exit $E_WRONG_ARGS
    fi


